<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The Lensing Posterior Â· CMBLensing.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/cmblensing.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CMBLensing.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">CMBLensing.jl</a></li><li><a class="toctext" href="../lense_a_map/">Lensing a flat map</a></li><li class="current"><a class="toctext" href>The Lensing Posterior</a><ul class="internal"><li><a class="toctext" href="#Posterior-basics-1">Posterior basics</a></li><li><a class="toctext" href="#Wiener-filtering-1">Wiener filtering</a></li><li><a class="toctext" href="#Posterior-gradients-1">Posterior gradients</a></li><li><a class="toctext" href="#Marginal-posterior-1">Marginal posterior</a></li></ul></li><li><a class="toctext" href="../joint_MAP_example/">Joint maximum a posterior estimate</a></li><li><a class="toctext" href="../from_python/">Using CMBLensing.jl from Python</a></li><li><a class="toctext" href="../api/">API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>The Lensing Posterior</a></li></ul></nav><hr/><div id="topbar"><span>The Lensing Posterior</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="The-Lensing-Posterior-1" href="#The-Lensing-Posterior-1">The Lensing Posterior</a></h1><p>Much of what the CMBLensing package does is centered on the &quot;CMB lensing posterior&quot;. We refer to either the &quot;<strong>joint posterior</strong>&quot;, </p><div>\[ \mathcal{P}(f,\phi,\theta\,|\,d), \]</div><p>where</p><ul><li><span>$f$</span> are the CMB fields (T/Q/U)</li><li><span>$\phi$</span> is the lensing potential</li><li><span>$\theta$</span> are any cosmological parameters</li><li><span>$d$</span> is the data,</li></ul><p>or the &quot;<strong>marginal posterior</strong>&quot;, </p><div>\[ \mathcal{P}(\phi,\theta\,|\,d) \equiv \int \! \mathcal{D}f \; \mathcal{P}(f,\phi,\theta\,|\,d), \]</div><p>which is simply the joint posterior marginalized over <span>$f$</span>. </p><p>We assume the following data model, which is generally flexible enough to handle real experiments:</p><div>\[ d = \mathbb{P} \, \mathbb{M} \, \mathbb{B} \, \mathbb{L}(\phi) \, f + n, \]</div><p>where </p><ul><li><span>$\mathbb{L}(\phi)$</span> is the lensing operation</li><li><span>$\mathbb{B}$</span> is an instrumental transfer function or &quot;beam&quot;</li><li><span>$\mathbb{M}$</span> is a user-chosen mask</li><li><span>$\mathbb{P}$</span> is a pixelization operation which allows one to estimate <span>$f$</span> on a higher resolution than the data</li><li><span>$n$</span> is the instrumental noise. </li></ul><p>Given this model, the joint posterior (up to an unimportant normalization constant) in the &quot;<strong>unlensed parameterization</strong>&quot;, is:</p><div>\[ 
-2\ln\mathcal{P}(f,\phi,\theta\,|\,d) = \frac{\big(d - \mathbb{P} \, \mathbb{M} \, \mathbb{B} \, \mathbb{L}(\phi) \, f\big)^2}{\mathbb{C}_n}
+ \frac{f^2}{\mathbb{C}_f(\theta)} + \frac{\phi^2}{C_\phi(\theta)} + \log\det \mathbb{C}_f(\theta) + \log\det C_\phi(\theta),
\]</div><p>where</p><ul><li><span>$\mathbb{C}_n$</span> is the noise covariance</li><li><span>$\mathbb{C}_f$</span> is the CMB covariance (i.e. the CMB T, E, and B <span>$C_\ell$</span>&#39;s)</li><li><span>$\mathbb{C}_\phi$</span> is the lensing potential covariance (i.e. <span>$C_\ell^{\phi\phi}$</span>)</li></ul><p>and we have used the slighly sloppy notation <span>$x^2/\mathbb{C}$</span> to mean <span>$x^\dagger \mathbb{C}^{-1} x$</span>.</p><p>It&#39;s often useful to parameterize this in terms of the lensed <span>$\tilde f = \mathbb{L}(\phi) f$</span> (this reduces correlations), in which case we have the &quot;&quot;<strong>lensed parametrization</strong>&quot;:</p><div>\[ 
-2\ln\mathcal{P}(\tilde f,\phi,\theta\,|\,d) = \frac{\big(d - \mathbb{P} \, \mathbb{M} \, \mathbb{B} \, \tilde f\big)^2}{\mathbb{C}_n}
+ \frac{\big(\mathbb{L}(\phi)^{-1} \tilde f\big)^2}{\mathbb{C}_f(\theta)} + \frac{\phi^2}{C_\phi(\theta)} + \log\det \mathbb{C}_f(\theta) + \log\det C_\phi(\theta),
\]</div><h2><a class="nav-anchor" id="Posterior-basics-1" href="#Posterior-basics-1">Posterior basics</a></h2><p>CMBLensing uses the function <code>lnP</code> to compute the log of the joint posterior probability.</p><pre class="language-julia"><code class="language-julia">using CMBLensing</code></pre><pre class="language-julia"><code class="language-julia">lnP</code></pre><pre class="language-none"><code class="language-none">lnP (generic function with 9 methods)</code></pre><p>To evaluate this posterior, we need the arguments of the probability distribution, <span>$f$</span>, <span>$\phi$</span>, and <span>$\theta$</span>. We also need the data <span>$d$</span> and host of other operators and covariances which enter the expressions above, which CMBLensing stores in a <code>DataSet</code> object.</p><p>First lets load up some simulated data. We&#39;ll use 1<span>$\mu$</span>K-arcmin noise and a border mask:</p><pre class="language-julia"><code class="language-julia">@unpack f, Ï•, ds = load_sim_dataset(
    Î¸pix      = 2,
    Nside     = 256,
    T         = Float32,
    use       = :P,
    Î¼KarcminT = 1,
    mask_kwargs = (paddeg=1, nsources=0)
);</code></pre><p>The <code>DataSet</code> object, <code>ds</code>, stores all the aforementioned quantities:</p><pre class="language-julia"><code class="language-julia">fieldnames(typeof(ds))</code></pre><pre class="language-none"><code class="language-none">(:d, :Cn, :CÏ•, :Cf, :CfÌƒ, :CnÌ‚, :M, :B, :BÌ‚, :D, :G, :P)</code></pre><p>For example, the data is:</p><pre class="language-julia"><code class="language-julia">plot(ds.d);</code></pre><p><img src="../posterior_files/posterior_13_0.png" alt="png"/></p><p>We can now evaluate the posterior, for example at the true <span>$f$</span> and <span>$\phi$</span>:</p><pre class="language-julia"><code class="language-julia">-2*lnP(0, f, Ï•, ds)</code></pre><pre class="language-none"><code class="language-none">306882.90319405496</code></pre><p>The first argument, <code>0</code>, indicates that this is in the unlensed parameterization. We could also use <code>1</code> for the lensed parametriation. (The <code>0</code> and <code>1</code> refer to auxillary &quot;time&quot; variable in the LenseFlow expansion, <span>$f(x+t\nabla\phi)$</span>; at <span>$t=0$</span> we have the unlensed field, and at <span>$t=1$</span> we have the lensed field). If we use the lensed parametrization, then the <span>$f$</span> argument to the function is expected to be the lensed field.</p><pre class="language-julia"><code class="language-julia">-2*lnP(1, LenseFlow(Ï•)*f, Ï•, ds)</code></pre><pre class="language-none"><code class="language-none">307156.48902226775</code></pre><p>Any difference between these two is due only to the error in the LenseFlow inverse operation. The difference we see here is fine, but in theory we can make the difference arbitrarily small by cranking up the number of LenseFlow ODE steps:</p><pre class="language-julia"><code class="language-julia">let L = LenseFlow(Ï•,30)
    -2*lnP(1, L*f, Ï•, ds, L)
end</code></pre><pre class="language-none"><code class="language-none">306882.88420174696</code></pre><p>We expect minus twice the posterior evaluated at the truth to be distributed like a <span>$\chi^2$</span> distribution where the degrees of freedom equals the number of pixels in <span>$d$</span>, <span>$f$</span>, and <span>$\phi$</span> (i.e. in each of the three Gaussian terms in the posterior). Since these maps are 256x256 and <span>$d$</span> and <span>$f$</span> have both Q and U maps, this is:</p><pre class="language-julia"><code class="language-julia">(2+2+1)*256^2</code></pre><pre class="language-none"><code class="language-none">327680</code></pre><p>which the previous result is within a few sigma of.</p><p>Above, we didn&#39;t specify any cosmological parameters, <span>$\theta$</span>. Because of that, they were fixed at their fiducial values (i.e. the fiducial values which generated the simulated data in the call to <code>load_sim_dataset</code> earlier). Current only two parameters can be varied, <span>$r$</span> (tensor-to-scalar ratio), and <span>$A_\phi$</span> (the amplitude of <span>$C_\ell^{\phi \phi}$</span>). They can be specified as follows, with non-specified parameters left at their fiducial:</p><pre class="language-julia"><code class="language-julia">-2*lnP(0, f, Ï•, (AÏ•=1.1,), ds)</code></pre><pre class="language-none"><code class="language-none">307200.19728863984</code></pre><p>You can see the slight change compared to what we got above. We can even compute a whole slice through the posterior along <span>$A_\phi$</span>:</p><pre class="language-julia"><code class="language-julia">AÏ•s = range(0.5,1.5,length=50)
plot(AÏ•s, [lnP(0, f, Ï•, (AÏ•=AÏ•,), ds) for AÏ• in AÏ•s])
xlabel(raw&quot;$A_\phi$&quot;)
ylabel(raw&quot;$\mathcal{P}(f_{\rm true}, \phi_{\rm true}, A_\phi\,|\,d)$&quot;);</code></pre><p><img src="../posterior_files/posterior_26_0.png" alt="png"/></p><h2><a class="nav-anchor" id="Wiener-filtering-1" href="#Wiener-filtering-1">Wiener filtering</a></h2><p>If we fix <span>$\phi$</span> and <span>$\theta$</span> then maximize the joint posterior, <span>$\mathcal{P}(f,\phi,\theta\,|\,d)$</span>, over <span>$f$</span>, we get</p><div>\[
\hat f_{\rm wf} = \big[ \mathbb{C}_f(\theta)^{-1} + \mathbb{A}^\dagger\mathbb{C}_n^{-1}\mathbb{A} \big]^{-1} \mathbb{A}^\dagger\mathbb{C}_n^{-1}d
\]</div><p>where</p><div>\[
\mathbb{A} = \mathbb{M} \, \mathbb{P}\,  \mathbb{B} \, \mathbb{L}(\phi)
\]</div><p>This is simply the Wiener filter of the data, and we can compute it by inverting the operator in brackets above with e.g. Conjugate Gradient. </p><p>In CMBLensing, the <code>argmaxf_lnP</code> function performs this task. Its arguments are similar to <code>lnP</code>,</p><pre class="language-julia"><code class="language-julia">f_wf = argmaxf_lnP(Ï•, (AÏ•=1,), ds, progress=true)</code></pre><pre class="language-none"><code class="language-none">[32mConjugate Gradient: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| Time: 0:00:50[39m</code></pre><p>Since Wiener filtering is the best-fit of the joint posterior at a fixed <span>$\phi$</span>, it is effectively delensing the data by a given <span>$\phi$</span>. Here we are Wiener filtering at the true <span>$\phi$</span>, so this is perfect delensing. </p><p>Note below the large amount of B mode power in the data, as well as the aliasing near the border mask, and how this is removed in the Wiener filtered B, which visually is tracing the true B map up to the level of the noise.</p><pre class="language-julia"><code class="language-julia">plot([ds.d, f_wf, f], title=[&quot;data &quot;, &quot;Wiener filtered &quot;, &quot;true &quot;] .* [&quot;E&quot; &quot;B&quot;]);</code></pre><p><img src="../posterior_files/posterior_32_0.png" alt="png"/></p><h2><a class="nav-anchor" id="Posterior-gradients-1" href="#Posterior-gradients-1">Posterior gradients</a></h2><h2><a class="nav-anchor" id="Marginal-posterior-1" href="#Marginal-posterior-1">Marginal posterior</a></h2><pre class="language-julia"><code class="language-julia"></code></pre><footer><hr/><a class="previous" href="../lense_a_map/"><span class="direction">Previous</span><span class="title">Lensing a flat map</span></a><a class="next" href="../joint_MAP_example/"><span class="direction">Next</span><span class="title">Joint maximum a posterior estimate</span></a></footer></article></body></html>
