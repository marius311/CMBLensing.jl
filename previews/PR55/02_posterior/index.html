<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The Lensing Posterior Â· CMBLensing.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/cmblensing.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CMBLensing.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">CMBLensing.jl</a></li><li><a class="tocitem" href="../01_lense_a_map/">Lensing a flat-sky map</a></li><li class="is-active"><a class="tocitem" href>The Lensing Posterior</a><ul class="internal"><li><a class="tocitem" href="#Posterior-basics-1"><span>Posterior basics</span></a></li><li><a class="tocitem" href="#Wiener-filtering-1"><span>Wiener filtering</span></a></li><li><a class="tocitem" href="#Posterior-gradients-1"><span>Posterior gradients</span></a></li><li><a class="tocitem" href="#Marginal-posterior-1"><span>Marginal posterior</span></a></li></ul></li><li><a class="tocitem" href="../03_joint_MAP_example/">MAP estimation</a></li><li><a class="tocitem" href="../04_from_python/">Calling from Python</a></li><li><a class="tocitem" href="../05_field_basics/">Field Basics</a></li><li><a class="tocitem" href="../06_gpu/">GPU</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"></nav><div class="docs-right"><a class="docs-right" href="https://mybinder.org/v2/gh/marius311/CMBLensing.jl/gh-pages?urlpath=lab/tree/02_posterior.ipynb"><img src="https://mybinder.org/badge_logo.svg"/></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="The-Lensing-Posterior-1"><a class="docs-heading-anchor" href="#The-Lensing-Posterior-1">The Lensing Posterior</a><a class="docs-heading-anchor-permalink" href="#The-Lensing-Posterior-1" title="Permalink"></a></h1><p>At its heart, CMBLensing.jl is centered around the &quot;CMB lensing posterior&quot;. We work with both the &quot;<strong>joint posterior</strong>&quot;, which is joint over all variables,</p><div>\[ \mathcal{P}(f,\phi,\theta\,|\,d), \]</div><p>or the &quot;<strong>marginal posterior</strong>&quot;, </p><div>\[ \mathcal{P}(\phi,\theta\,|\,d) \equiv \int \! \mathcal{D}f \; \mathcal{P}(f,\phi,\theta\,|\,d), \]</div><p>which is simply the joint posterior analytically marginalized over <span>$f$</span>. Here,</p><ul><li><span>$f$</span> are the CMB fields (T/Q/U),</li><li><span>$\phi$</span> is the lensing potential,</li><li><span>$\theta$</span> are any cosmological parameters,</li><li><span>$d$</span> is the data.</li></ul><p>The default data model which is assumed, which is generally flexible enough to handle real experiments (but can be customized), is:</p><div>\[ d =  \mathbb{A} \, \mathbb{L}(\phi) \, f + n, \]</div><p>where</p><div>\[ \mathbb{A} = \mathbb{M} \, \mathbb{B} \]</div><p>and </p><ul><li><span>$\mathbb{L}(\phi)$</span> is the lensing operation</li><li><span>$\mathbb{B}$</span> is an instrumental transfer function or &quot;beam&quot;</li><li><span>$\mathbb{M}$</span> is a user-chosen mask</li><li><span>$n$</span> is the instrumental noise. </li></ul><p>Given this model, the joint posterior (up to an unimportant normalization constant) is:</p><div>\[ 
-2\ln\mathcal{P}(f,\phi,\theta\,|\,d) = \frac{\big(d - \mathbb{A} \, \mathbb{L}(\phi) \, f\big)^2}{\mathbb{C}_n}
+ \frac{f^2}{\mathbb{C}_f(\theta)} + \frac{\phi^2}{C_\phi(\theta)} + \log\det \mathbb{C}_f(\theta) + \log\det C_\phi(\theta),
\]</div><p>and the marginal posterior is:</p><div>\[ 
-2\ln\mathcal{P}(\phi,\theta\,|\,d) = \frac{d^2}{\mathbb{\Sigma}_d(\phi,\theta)} + \frac{\phi^2}{C_\phi(\theta)} + \log\det \mathbb{\Sigma}_d(\phi,\theta) + \log\det C_\phi(\theta),
\]</div><p>where</p><div>\[
\Sigma_d = \mathbb{A} \, \mathbb{L}(\phi) \, \mathbb{C}_f(\theta) \, \mathbb{L}(\phi)^\dagger \mathbb{A}^\dagger + \mathbb{C}_n
\]</div><p>and</p><ul><li><span>$\mathbb{C}_n$</span> is the noise covariance</li><li><span>$\mathbb{C}_f$</span> is the CMB covariance (i.e. the CMB T, E, and B <span>$C_\ell$</span>&#39;s)</li><li><span>$\mathbb{C}_\phi$</span> is the lensing potential covariance (i.e. <span>$C_\ell^{\phi\phi}$</span>)</li></ul><p>and we have used the slighly sloppy notation <span>$x^2/\mathbb{C}$</span> to mean <span>$x^\dagger \mathbb{C}^{-1} x$</span>.</p><h2 id="Posterior-basics-1"><a class="docs-heading-anchor" href="#Posterior-basics-1">Posterior basics</a><a class="docs-heading-anchor-permalink" href="#Posterior-basics-1" title="Permalink"></a></h2><pre class="language-julia"><code class="language-julia">using CMBLensing, PyPlot</code></pre><p>CMBLensing uses the function <code>lnP</code> to compute the log of the joint posterior probability. </p><p>To evaluate this posterior, we need the arguments of the probability distribution, <span>$f$</span>, <span>$\phi$</span>, and <span>$\theta$</span>. We also need the data <span>$d$</span> and host of other operators and covariances which enter the expressions above, which CMBLensing stores in a <code>DataSet</code> object.</p><p>First lets load up some simulated data. The function <code>load_sim</code> handles constructing a <code>DataSet</code> and is the recommended way to create the various fields and covariances needed. In this case, let&#39;s use 1<span>$\mu$</span>K-arcmin noise and a border mask:</p><pre class="language-julia"><code class="language-julia">@unpack f, fÌƒ, Ï•, ds = load_sim(
    Î¸pix      = 2,
    Nside     = 256,
    T         = Float64,
    pol       = :P,
    Î¼KarcminT = 1,
    L         = LenseFlow{RK4Solver{10}},
    seed      = 0,
    pixel_mask_kwargs = (edge_padding_deg=1, apodization_deg=0, num_ptsrcs=0),
    bandpass_mask     = LowPass(5000)
);</code></pre><p>The <code>DataSet</code> object, by convention called <code>ds</code>, stores all the aforementioned quantities:</p><pre class="language-julia"><code class="language-julia">fieldnames(typeof(ds))</code></pre><pre class="language-output"><code class="language-output">(:d, :CÏ•, :Cf, :CfÌƒ, :Cn, :CnÌ‚, :M, :MÌ‚, :B, :BÌ‚, :D, :G, :L)</code></pre><p>For example, the data is:</p><pre class="language-julia"><code class="language-julia">plot(ds.d);</code></pre><p><img src="../02_posterior_files/02_posterior_11_0.png" alt="png"/></p><p>Or the diagonal of the <span>$\mathbb{C}_f$</span> operator:</p><pre class="language-julia"><code class="language-julia">plot(diag(ds.Cf), which=[:El :Bl])</code></pre><p><img src="../02_posterior_files/02_posterior_13_0.png" alt="png"/></p><p>We can now evaluate the posterior, for example at the true <span>$f$</span> and <span>$\phi$</span>:</p><pre class="language-julia"><code class="language-julia">-2*lnP(0, f, Ï•, ds)</code></pre><pre class="language-output"><code class="language-output">328189.9791983807</code></pre><p>The first argument, in this case <code>0</code>, indicates the parameterization. We can compute the posterior given a couple of different parametrizations,</p><ul><li>The unlensed parametrization, <span>$\mathcal{P}(f,\phi,\theta\,|\,d)$</span></li><li>The lensed parametrization, <span>$\mathcal{P}(\tilde f,\phi,\theta\,|\,d)$</span> where <span>$\tilde f$</span> are the <em>lensed</em> CMB fields.</li><li>The mixed parametrization, <span>$\mathcal{P}(f^\prime, \phi^\prime, \theta \,|\, d)$</span> where <span>$f^\prime$</span> and <span>$\phi^\prime$</span> are the <em>mixed</em> CMB fields and lensing potential (this is a parametrization which attemps to decorrelate the posterior as much as possible; you may want to read <a href="https://arxiv.org/TBD">our paper</a> which describes this in more detail).</li></ul><p>For the unlensed and lensed parametrizations, pass <code>0</code> and <code>1</code> as the first argument  (these refer to auxillary &quot;time&quot; variable in the LenseFlow expansion, <span>$f(x+t\nabla\phi)$</span>; at <span>$t=0$</span> we have the unlensed field, and at <span>$t=1$</span> we have the lensed field). If we use the lensed parametrization, then the <span>$f$</span> argument to the function is expected to be the lensed field. The mixed parametrization can be specified by passing <code>:mix</code> as the first argment, in which case the <span>$f$</span> argument is expected to be the mixed field.</p><p>For example, the following is the same point in parameter space that we evaluated above, just in a different parametrization (any differences to the above value are numerical):</p><pre class="language-julia"><code class="language-julia">-2*lnP(1, ds.L(Ï•)*f, Ï•, ds)</code></pre><pre class="language-output"><code class="language-output">328193.6545851368</code></pre><p>We expect minus twice the posterior evaluated at the truth to be distributed like a <span>$\chi^2$</span> distribution where the degrees of freedom equals the number of pixels in <span>$d$</span>, <span>$f$</span>, and <span>$\phi$</span> (i.e. in each of the three Gaussian terms in the posterior). Since these maps are 256x256 and <span>$d$</span> and <span>$f$</span> have both Q and U maps, this is:</p><pre class="language-julia"><code class="language-julia">(2+2+1)*256^2</code></pre><pre class="language-output"><code class="language-output">327680</code></pre><p>which the previous result is within a few sigma of.</p><p>Above, we didn&#39;t specify any cosmological parameters, <span>$\theta$</span>. Because of that, they were fixed at their fiducial values (i.e. the fiducial values which generated the simulated data in the call to <code>load_sim</code> earlier). Current only two parameters can be varied, <span>$r$</span> (tensor-to-scalar ratio), and <span>$A_\phi$</span> (the amplitude of <span>$C_\ell^{\phi \phi}$</span>). They can be specified as follows, with non-specified parameters left at their fiducial:</p><pre class="language-julia"><code class="language-julia">-2*lnP(0, f, Ï•, (AÏ•=1.1,), ds)</code></pre><pre class="language-output"><code class="language-output">328460.49990680604</code></pre><p>You can see the slight change compared to what we got above. We can even compute a whole slice through the posterior along <span>$A_\phi$</span>:</p><pre class="language-julia"><code class="language-julia">AÏ•s = range(0.5,1.5,length=50)
plot(AÏ•s, [lnP(0, f, Ï•, (AÏ•=AÏ•,), ds) for AÏ• in AÏ•s])
xlabel(raw&quot;$A_\phi$&quot;)
ylabel(raw&quot;$\mathcal{P}(f_{\rm true}, \phi_{\rm true}, A_\phi\,|\,d)$&quot;);</code></pre><p><img src="../02_posterior_files/02_posterior_25_0.png" alt="png"/></p><h2 id="Wiener-filtering-1"><a class="docs-heading-anchor" href="#Wiener-filtering-1">Wiener filtering</a><a class="docs-heading-anchor-permalink" href="#Wiener-filtering-1" title="Permalink"></a></h2><p>If we fix <span>$\phi$</span> and <span>$\theta$</span> then maximize the joint posterior, <span>$\mathcal{P}(f,\phi,\theta\,|\,d)$</span>, over <span>$f$</span>, we get</p><div>\[
\hat f_{\rm wf} = \big[ \mathbb{C}_f(\theta)^{-1} + \mathbb{L}(\phi)^\dagger \mathbb{A}^\dagger\mathbb{C}_n^{-1}\mathbb{A} \, \mathbb{L}(\phi) \big]^{-1} \mathbb{L}(\phi)^\dagger \mathbb{A}^\dagger\mathbb{C}_n^{-1}d
\]</div><p>This is simply the Wiener filter of the data given a signal covariance which includes correlations induced by <span>$\phi$</span>, and we can compute it by inverting the operator in brackets above with e.g. conjugate gradient. </p><p>In CMBLensing.jl, the <code>argmaxf_lnP</code> function performs this task. Its arguments are similar to <code>lnP</code>,</p><pre class="language-julia"><code class="language-julia">f_wf = argmaxf_lnP(Ï•, (AÏ•=1,), ds, conjgrad_kwargs=(tol=1e-1,progress=true));</code></pre><pre class="language-output"><code class="language-output">[32mConjugate Gradient: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| Time: 0:00:27[39m</code></pre><p>Wiener filtering effectively delenses the data by a given <span>$\phi$</span>. Here we are Wiener filtering at the true <span>$\phi$</span>, so this is perfect delensing. Note below the large amount of B mode power in the data, as well as the aliasing near the border mask, and how this is removed in the Wiener filtered B, which visually is tracing the true B map up to the level of the noise.</p><pre class="language-julia"><code class="language-julia">plot([ds.d, f_wf, f], title=[&quot;data &quot;, &quot;Wiener filtered &quot;, &quot;true &quot;] .* [&quot;E&quot; &quot;B&quot;]);</code></pre><p><img src="../02_posterior_files/02_posterior_31_0.png" alt="png"/></p><h2 id="Posterior-gradients-1"><a class="docs-heading-anchor" href="#Posterior-gradients-1">Posterior gradients</a><a class="docs-heading-anchor-permalink" href="#Posterior-gradients-1" title="Permalink"></a></h2><p>Fundamental to maximization and sampling algorithms in high dimensions are gradients of the posterior. CMBLensing.jl uses the interface provided by the automatic differentiation library <a href="https://github.com/FluxML/Zygote.jl/">Zygote</a> to compute these gradients.</p><pre class="language-julia"><code class="language-julia">using Zygote</code></pre><p>Zygote provides the <code>gradient</code> function, which takes a function for which to evaluate the gradient as the first argument, and the value at which to evaluate the gradient as the second argument. For example:</p><pre class="language-julia"><code class="language-julia">gradient(x-&gt;3x^2+2x, 1)</code></pre><pre class="language-output"><code class="language-output">(8,)</code></pre><p>Gradients of the CMB lensing posterior work in exactly the same way. For example, to take the gradient with respect to <span>$\phi$</span> in the lensed parametrization, where we fix <span>$f$</span> to the Wiener filter computed above and evaluate the gradient at <span>$\phi=0$</span>, we can do:</p><pre class="language-julia"><code class="language-julia">gÏ• = gradient(Ï• -&gt; lnP(1,f_wf,Ï•,ds), 0Ï•)[1];</code></pre><p>Here&#39;s what this gradient looks like multiplied by <span>$\mathbb{C}_\phi$</span>. This is actually the first gradient step in the iterative joint maximum a posteriori estimation. The feature you see below is the mean-field in this estimate due to the mask:</p><pre class="language-julia"><code class="language-julia">plot(ds.CÏ•*gÏ•)</code></pre><p><img src="../02_posterior_files/02_posterior_40_0.png" alt="png"/></p><p>You are free to manipulate the fields inside of the function whose gradient is being taken, and Zygote will automatically propagate the chain rule for you:</p><pre class="language-julia"><code class="language-julia">gradient(Ï• -&gt; -2lnP(1,f_wf,3Ï•,ds), 0Ï•)[1] â‰ˆ -6 * gradient(Ï• -&gt; lnP(1,f_wf,Ï•,ds), 0Ï•)[1]</code></pre><pre class="language-output"><code class="language-output">true</code></pre><p>Automatic differentiation with respect to any and all arguments of <code>lnP</code> works, including the cosmological parameters:</p><pre class="language-julia"><code class="language-julia">gradient(AÏ• -&gt; lnP(1,f_wf,Ï•,(AÏ•=AÏ•,),ds), 1)[1]</code></pre><pre class="language-output"><code class="language-output">98.47558778092935</code></pre><p>Currently Zygote is working with many (but not all) operations that you can do to fields. If you run into things which Zygote is not able to differentiate successfully (generally you&#39;ll get some error), please feel free to file an <a href="https://github.com/marius311/CMBLensing.jl/issues">Issue</a> with CMBLensing.jl.</p><h2 id="Marginal-posterior-1"><a class="docs-heading-anchor" href="#Marginal-posterior-1">Marginal posterior</a><a class="docs-heading-anchor-permalink" href="#Marginal-posterior-1" title="Permalink"></a></h2><p><em>work in progress</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../01_lense_a_map/">Â« Lensing a flat-sky map</a><a class="docs-footer-nextpage" href="../03_joint_MAP_example/">MAP estimation Â»</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 15 April 2021 09:00">Thursday 15 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
