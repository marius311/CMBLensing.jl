<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Field Basics · CMBLensing.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/cmblensing.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CMBLensing.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">CMBLensing.jl</a></li><li><a class="tocitem" href="../01_lense_a_map/">Lensing a flat-sky map</a></li><li><a class="tocitem" href="../02_posterior/">The Lensing Posterior</a></li><li><a class="tocitem" href="../03_joint_MAP_example/">MAP estimation</a></li><li><a class="tocitem" href="../04_from_python/">Calling from Python</a></li><li class="is-active"><a class="tocitem" href>Field Basics</a><ul class="internal"><li><a class="tocitem" href="#Base-Fields"><span>Base Fields</span></a></li><li><a class="tocitem" href="#Diagonal-operators"><span>Diagonal operators</span></a></li><li><a class="tocitem" href="#Field-Tuples"><span>Field Tuples</span></a></li><li><a class="tocitem" href="#Field-Vectors"><span>Field Vectors</span></a></li><li><a class="tocitem" href="#Basis-Conversion"><span>Basis Conversion</span></a></li><li><a class="tocitem" href="#Properties-and-indices"><span>Properties and indices</span></a></li></ul></li><li><a class="tocitem" href="../06_gpu/">GPU</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"></nav><div class="docs-right"><a class="docs-right" href="https://mybinder.org/v2/gh/marius311/CMBLensing.jl/gh-pages?urlpath=lab/tree/05_field_basics.ipynb"><img src="https://mybinder.org/badge_logo.svg"/></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Field-Basics"><a class="docs-heading-anchor" href="#Field-Basics">Field Basics</a><a id="Field-Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Field-Basics" title="Permalink"></a></h1><pre><code class="language-julia hljs">using CMBLensing</code></pre><h2 id="Base-Fields"><a class="docs-heading-anchor" href="#Base-Fields">Base Fields</a><a id="Base-Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Base-Fields" title="Permalink"></a></h2><p>The basic building blocks of CMBLensing.jl are CMB &quot;fields&quot;, like temperature, Q or U polarization, or the lensing potential <span>$\phi$</span>. These types are all encompassed by the abstract type <code>Field</code>, with some concrete examples including <code>FlatMap</code> for a flat-sky map projection, or <code>FlatQUMap</code> for Q/U polarization, etc...</p><p><code>Flat</code> fields are just thin wrappers around Julia arrays, e.g.</p><pre><code class="language-julia hljs">Ix = rand(2,2)</code></pre><pre><code class="language-output hljs ansi">2×2 Matrix{Float64}:
 0.019993  0.0170176
 0.248323  0.470118</code></pre><pre><code class="language-julia hljs">f = FlatMap(Ix)</code></pre><pre><code class="language-output hljs ansi">4-element 2×2-pixel 1.0′-resolution LambertMap{Array{Float64, 2}}:
 0.019992952067787617
 0.24832280026579556
 0.017017591848834113
 0.4701179188511494</code></pre><p>When displayed, you can see the pixels in the 2x2 map have been splayed out into a length-4 array. This is intentional, as even though the maps themselves are two-dimensional, it is extremely useful conceptually to think of fields as vectors (which they are, in fact, as they form an <a href="https://en.wikipedia.org/wiki/Vector_space">abstract vector space</a>). This tie to vector spaces is deeply rooted in CMBLensing, to the extent that <code>Field</code> objects are a subtype of Julia&#39;s own <code>AbstractVector</code> type, </p><pre><code class="language-julia hljs">f isa AbstractVector</code></pre><pre><code class="language-output hljs ansi">true</code></pre><p>The data itself, however, is still stored as the original 2x2 matrix, and can be accessed as follows,</p><pre><code class="language-julia hljs">f.Ix</code></pre><pre><code class="language-output hljs ansi">2×2 view(::Matrix{Float64}, :, :) with eltype Float64:
 0.019993  0.0170176
 0.248323  0.470118</code></pre><p>But since <code>Fields</code> are vectors, they can be tranposed,</p><pre><code class="language-julia hljs">f&#39;</code></pre><pre><code class="language-output hljs ansi">1×4 adjoint(::LambertMap{Array{Float64, 2}}) with eltype Float64:
 0.019993  0.248323  0.0170176  0.470118</code></pre><p>inner products can be computed,</p><pre><code class="language-julia hljs">f&#39; * f</code></pre><pre><code class="language-output hljs ansi">0.28336438732150043</code></pre><p>and they can be added with each other as well as multiplied by scalars,</p><pre><code class="language-julia hljs">2*f+f</code></pre><pre><code class="language-output hljs ansi">4-element 2×2-pixel 1.0′-resolution LambertMap{Array{Float64, 2}}:
 0.05997885620336285
 0.7449684007973867
 0.05105277554650234
 1.410353756553448</code></pre><h2 id="Diagonal-operators"><a class="docs-heading-anchor" href="#Diagonal-operators">Diagonal operators</a><a id="Diagonal-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Diagonal-operators" title="Permalink"></a></h2><p>Vector spaces have linear operators which act on the vectors. Linear operators correpsond to matrices, thus for a map with <span>$N$</span> total pixels, a general linear operator would be an <span>$N$</span>-by-<span>$N$</span> matrix, which for even modest map sizes becomes far too large to actually store. Thus, an important class of linear operators are ones which are diagonal, since these can actually be stored. CMBLensing uses Julia&#39;s builtin <code>Diagonal</code> to represent these. <code>Diagonal(f)</code> takes a vector <code>f</code> and puts it on the diagonal of the matrix:</p><pre><code class="language-julia hljs">Diagonal(f)</code></pre><pre><code class="language-output hljs ansi">4×4 Diagonal{Float64, BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}}:
 0.019993   ⋅         ⋅          ⋅ 
  ⋅        0.248323   ⋅          ⋅ 
  ⋅         ⋅        0.0170176   ⋅ 
  ⋅         ⋅         ⋅         0.470118</code></pre><p>Multiplying this operator by the original map is then a matrix-vector product:</p><pre><code class="language-julia hljs">Diagonal(f) * f</code></pre><pre><code class="language-output hljs ansi">4-element 2×2-pixel 1.0′-resolution LambertMap{Array{Float64, 2}}:
 0.00039971813238485316
 0.061664213131846196
 0.0002895984323335052
 0.22101085762493589</code></pre><p>Note that this is also equal to the the pointwise multiplication of <code>f</code> with itself:</p><pre><code class="language-julia hljs">f .* f</code></pre><pre><code class="language-output hljs ansi">4-element 2×2-pixel 1.0′-resolution LambertMap{Array{Float64, 2}}:
 0.00039971813238485316
 0.061664213131846196
 0.0002895984323335052
 0.22101085762493589</code></pre><h2 id="Field-Tuples"><a class="docs-heading-anchor" href="#Field-Tuples">Field Tuples</a><a id="Field-Tuples-1"></a><a class="docs-heading-anchor-permalink" href="#Field-Tuples" title="Permalink"></a></h2><p>You can put <code>Fields</code> together into tuples. For example, </p><pre><code class="language-julia hljs">a = FlatMap(rand(2,2))
b = FlatMap(rand(2,2));</code></pre><pre><code class="language-julia hljs">FieldTuple(a,b)</code></pre><pre><code class="language-output hljs ansi">8-element Field-2-Tuple{BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}, BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}}:
 0.6828252258631178
 0.9153594871991504
 0.30153657550854873
 0.5162829197793188
 0.18060558756188383
 0.8987023709469601
 0.9040405677681655
 0.7569271896823323</code></pre><p>The components can also have names:</p><pre><code class="language-julia hljs">ft = FieldTuple(a=a, b=b)</code></pre><pre><code class="language-output hljs ansi">8-element Field-(a,b)-Tuple{BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}, BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}}:
 0.6828252258631178
 0.9153594871991504
 0.30153657550854873
 0.5162829197793188
 0.18060558756188383
 0.8987023709469601
 0.9040405677681655
 0.7569271896823323</code></pre><p>which can be accessed later:</p><pre><code class="language-julia hljs">ft.a</code></pre><pre><code class="language-output hljs ansi">4-element 2×2-pixel 1.0′-resolution LambertMap{Array{Float64, 2}}:
 0.6828252258631178
 0.9153594871991504
 0.30153657550854873
 0.5162829197793188</code></pre><p><code>FieldTuples</code> have all of the same behavior of individual fields. Indeed, spin fields like QU or IQU are simply special <code>FieldTuples</code>:</p><pre><code class="language-julia hljs">fqu = FlatQUMap(a,b)
fqu isa FieldTuple</code></pre><pre><code class="language-output hljs ansi">false</code></pre><h2 id="Field-Vectors"><a class="docs-heading-anchor" href="#Field-Vectors">Field Vectors</a><a id="Field-Vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Field-Vectors" title="Permalink"></a></h2><p><em>in progress</em></p><h2 id="Basis-Conversion"><a class="docs-heading-anchor" href="#Basis-Conversion">Basis Conversion</a><a id="Basis-Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Basis-Conversion" title="Permalink"></a></h2><p>All fields are tagged as to which basis they are stored in. You can convert them to other bases by calling the basis type on them:</p><pre><code class="language-julia hljs">f</code></pre><pre><code class="language-output hljs ansi">4-element 2×2-pixel 1.0′-resolution LambertMap{Array{Float64, 2}}:
 0.019992952067787617
 0.24832280026579556
 0.017017591848834113
 0.4701179188511494</code></pre><pre><code class="language-julia hljs">g = Fourier(f)</code></pre><pre><code class="language-output hljs ansi">4-element 2×2-pixel 1.0′-resolution LambertFourier{Array{ComplexF64, 2}}:
   0.7554512630335667 + 0.0im
  -0.6814301752003232 + 0.0im
 -0.21881975836640033 + 0.0im
  0.22477047880430734 + 0.0im</code></pre><p>Basis conversion is usually done automatically for you. E.g. here <code>f′</code> is automatically converted to a <code>FlatMap</code> before addition:</p><pre><code class="language-julia hljs">f + g</code></pre><pre><code class="language-output hljs ansi">4-element 2×2-pixel 1.0′-resolution LambertMap{Array{Float64, 2}}:
 0.039985904135575234
 0.4966456005315911
 0.034035183697668225
 0.9402358377022988</code></pre><p>A key feature of <code>Diagonal</code> operators is they convert the field they are acting on to the right basis before multiplication:</p><pre><code class="language-julia hljs">Diagonal(f) * g</code></pre><pre><code class="language-output hljs ansi">4-element 2×2-pixel 1.0′-resolution LambertMap{Array{Float64, 2}}:
 0.00039971813238485316
 0.061664213131846196
 0.0002895984323335052
 0.22101085762493589</code></pre><p>A <code>FlatMap</code> times a <code>FlatFourier</code> doesn&#39;t have a natural linear algebra meaning so its an error:</p><pre><code class="language-julia hljs">f * g</code></pre><pre><code class="nohighlight hljs">MethodError: no method matching *(::BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}, ::BaseField{Fourier, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, ComplexF64, Matrix{ComplexF64}})

Closest candidates are:
  *(::Any, ::Any, ::Any, ::Any...)
   @ Base operators.jl:578
  *(::BilinearLens, ::BaseField{B, M, T, A} where {B, M&lt;:CMBLensing.FlatProj, T, A&lt;:(AbstractArray{T})})
   @ CMBLensing ~/CMBLensing/src/bilinearlens.jl:128
  *(::AbstractFFTs.ScaledPlan, ::AbstractArray)
   @ AbstractFFTs ~/.julia/packages/AbstractFFTs/0uOAT/src/definitions.jl:264
  ...




Stacktrace:

 [1] top-level scope

   @ In[21]:1</code></pre><h2 id="Properties-and-indices"><a class="docs-heading-anchor" href="#Properties-and-indices">Properties and indices</a><a id="Properties-and-indices-1"></a><a class="docs-heading-anchor-permalink" href="#Properties-and-indices" title="Permalink"></a></h2><p><code>FlatMap</code> and <code>FlatFourier</code> can be indexed directly like arrays. If given 1D indices, this is the index into the vector representation:</p><pre><code class="language-julia hljs">f</code></pre><pre><code class="language-output hljs ansi">4-element 2×2-pixel 1.0′-resolution LambertMap{Array{Float64, 2}}:
 0.019992952067787617
 0.24832280026579556
 0.017017591848834113
 0.4701179188511494</code></pre><pre><code class="language-julia hljs">f[1], f[2], f[3], f[4]</code></pre><pre><code class="language-output hljs ansi">(0.019992952067787617, 0.24832280026579556, 0.017017591848834113, 0.4701179188511494)</code></pre><pre><code class="language-julia hljs">f[5]</code></pre><pre><code class="nohighlight hljs">BoundsError: attempt to access 2×2 Matrix{Float64} at index [5]



Stacktrace:

 [1] getindex

   @ ./essentials.jl:13 [inlined]

 [2] getindex(f::BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}, I::Int64)

   @ CMBLensing ~/CMBLensing/src/base_fields.jl:36

 [3] top-level scope

   @ In[24]:1</code></pre><p>Or with a 2D index, this indexes directly into the 2D map:</p><pre><code class="language-julia hljs">f[1,1], f[2,1], f[1,2], f[2,2]</code></pre><pre><code class="language-output hljs ansi">(0.019992952067787617, 0.24832280026579556, 0.017017591848834113, 0.4701179188511494)</code></pre><p><em>Note:</em> there is no overhead to indexing <code>f</code> in this way as compared to working directly on the underlying array.</p><p>For other fields which are built on <code>FieldTuples</code>, 1D indexing will instead index the tuple indices:</p><pre><code class="language-julia hljs">ft</code></pre><pre><code class="language-output hljs ansi">8-element Field-(a,b)-Tuple{BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}, BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}}:
 0.6828252258631178
 0.9153594871991504
 0.30153657550854873
 0.5162829197793188
 0.18060558756188383
 0.8987023709469601
 0.9040405677681655
 0.7569271896823323</code></pre><pre><code class="language-julia hljs">ft[1]</code></pre><pre><code class="language-output hljs ansi">4-element 2×2-pixel 1.0′-resolution LambertMap{Array{Float64, 2}}:
 0.6828252258631178
 0.9153594871991504
 0.30153657550854873
 0.5162829197793188</code></pre><pre><code class="language-julia hljs">ft[2]</code></pre><pre><code class="language-output hljs ansi">4-element 2×2-pixel 1.0′-resolution LambertMap{Array{Float64, 2}}:
 0.18060558756188383
 0.8987023709469601
 0.9040405677681655
 0.7569271896823323</code></pre><pre><code class="language-julia hljs">ft[3]</code></pre><pre><code class="nohighlight hljs">BoundsError: attempt to access NamedTuple{(:a, :b), Tuple{BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}, BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}}} at index [3]



Stacktrace:

 [1] getindex

   @ ./namedtuple.jl:136 [inlined]

 [2] getindex(f::FieldTuple{NamedTuple{(:a, :b), Tuple{BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}, BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}}}, CMBLensing.BasisProd{Tuple{Map, Map}}, Float64}, i::Int64)

   @ CMBLensing ~/CMBLensing/src/field_tuples.jl:33

 [3] top-level scope

   @ In[29]:1</code></pre><p>To get the underlying data arrays, use the object&#39;s properties:</p><pre><code class="language-julia hljs">f.Ix</code></pre><pre><code class="language-output hljs ansi">2×2 view(::Matrix{Float64}, :, :) with eltype Float64:
 0.019993  0.0170176
 0.248323  0.470118</code></pre><p>You can always find out what properties are available by typing <code>f.&lt;Tab&gt;</code>. For example, if you typed <code>ft</code> then hit <code>&lt;Tab&gt;</code> you&#39;d get:</p><pre><code class="language-julia hljs">ft |&gt; propertynames</code></pre><pre><code class="language-output hljs ansi">(:fs, :a, :b)</code></pre><p>For a <code>FieldTuple</code> like the <code>FlatQUMap</code> object, <code>fqu</code>, you can get each individual Q or U field:</p><pre><code class="language-julia hljs">fqu.Q</code></pre><pre><code class="language-output hljs ansi">4-element 2×2-pixel 1.0′-resolution LambertMap{SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}}:
 0.6828252258631178
 0.9153594871991504
 0.30153657550854873
 0.5162829197793188</code></pre><p>Or <code>fqu.Qx</code> which is shorthand for <code>fqu.Q.Ix</code>:</p><pre><code class="language-julia hljs">fqu.Q.Ix === fqu.Qx</code></pre><pre><code class="language-output hljs ansi">true</code></pre><p>If you convert <code>f</code> to Fourier space, it would have the <code>Il</code> property to get the Fourier coefficients of the <span>$I$</span> component:</p><pre><code class="language-julia hljs">Fourier(f).Il</code></pre><pre><code class="language-output hljs ansi">2×2 view(::Matrix{ComplexF64}, :, :) with eltype ComplexF64:
 0.755451+0.0im  -0.21882+0.0im
 -0.68143+0.0im   0.22477+0.0im</code></pre><p>For convenience, you can index fields with brackets <code>[]</code> and any necessary conversions will be done automatically:</p><pre><code class="language-julia hljs">f[:Il]</code></pre><pre><code class="language-output hljs ansi">2×2 view(::Matrix{ComplexF64}, :, :) with eltype ComplexF64:
 0.755451+0.0im  -0.21882+0.0im
 -0.68143+0.0im   0.22477+0.0im</code></pre><p>This works between any bases. For example. <code>fqu</code> is originally <code>QUMap</code> but we can convert to <code>EBFourier</code> and get the <code>El</code> coefficients:</p><pre><code class="language-julia hljs">fqu[:El]</code></pre><pre><code class="language-output hljs ansi">2×2 view(::Array{ComplexF64, 3}, :, :, 1) with eltype ComplexF64:
    -2.416-0.0im  -0.780365+0.0im
 -0.447281+0.0im    0.86521+0.0im</code></pre><p>The general rule to keep in mind for these two ways of accessing the underlying data is:</p><ul><li><strong>Properties</strong> (i.e. <code>f.Ix</code>) are type-stable and get you the underlying data arrays, even recursively from special <code>FieldTuples</code> like <code>FlatQUMap</code>, etc... If these arrays are modified, they affect the original field.</li><li><strong>Indices</strong> (i.e. <code>f[:Ix]</code>) are not type-stable, and may or may not be one of the underlying data arrays (because a basis conversion may have been performed). They should be used for getting (not setting) data, and in non-performance-critical code. </li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../04_from_python/">« Calling from Python</a><a class="docs-footer-nextpage" href="../06_gpu/">GPU »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 20 April 2023 07:56">Thursday 20 April 2023</span>. Using Julia version 1.9.0-rc2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
