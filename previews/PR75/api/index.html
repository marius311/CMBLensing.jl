<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · CMBLensing.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/cmblensing.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CMBLensing.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">CMBLensing.jl</a></li><li><a class="tocitem" href="../01_lense_a_map/">Lensing a flat-sky map</a></li><li><a class="tocitem" href="../02_posterior/">The Lensing Posterior</a></li><li><a class="tocitem" href="../03_joint_MAP_example/">MAP estimation</a></li><li><a class="tocitem" href="../04_from_python/">Calling from Python</a></li><li><a class="tocitem" href="../05_field_basics/">Field Basics</a></li><li><a class="tocitem" href="../06_gpu/">GPU</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Simulation-1"><span>Simulation</span></a></li><li><a class="tocitem" href="#Lensing-estimation-1"><span>Lensing estimation</span></a></li><li><a class="tocitem" href="#Field-constructors-1"><span>Field constructors</span></a></li><li><a class="tocitem" href="#Lensing-operators-1"><span>Lensing operators</span></a></li><li><a class="tocitem" href="#Configuration-options-1"><span>Configuration options</span></a></li><li><a class="tocitem" href="#Other-1"><span>Other</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-1"><a class="docs-heading-anchor" href="#API-1">API</a><a class="docs-heading-anchor-permalink" href="#API-1" title="Permalink"></a></h1><ul><li><a href="#API-1">API</a></li><ul><li><a href="#Simulation-1">Simulation</a></li><li><a href="#Lensing-estimation-1">Lensing estimation</a></li><li><a href="#Field-constructors-1">Field constructors</a></li><li><a href="#Lensing-operators-1">Lensing operators</a></li><li><a href="#Configuration-options-1">Configuration options</a></li><li><a href="#Other-1">Other</a></li></ul></ul><h2 id="Simulation-1"><a class="docs-heading-anchor" href="#Simulation-1">Simulation</a><a class="docs-heading-anchor-permalink" href="#Simulation-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.load_sim" href="#CMBLensing.load_sim"><code>CMBLensing.load_sim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre class="language-julia"><code class="language-julia">load_sim(;kwargs...)</code></pre><p>The starting point for many typical sessions. Creates a <code>BaseDataSet</code> object with some simulated data, returing the DataSet and simulated truths, which can then be passed to other maximization / sampling functions. E.g.:</p><pre class="language-julia"><code class="language-julia">@unpack f,ϕ,ds = load_sim(;
    θpix  = 2,
    Nside = 128,
    pol   = :P,
    T     = Float32
)</code></pre><p>Keyword arguments: </p><ul><li><code>θpix</code> — Angular resolution, in arcmin. </li><li><code>Nside</code> — Number of pixels in the map as an <code>(Ny,Nx)</code> tuple, or a single number for square maps. </li><li><code>pol</code> — One of <code>:I</code>, <code>:P</code>, or <code>:IP</code> to select intensity, polarization, or both. </li><li><code>T = Float32</code> — Precision, either <code>Float32</code> or <code>Float64</code>.</li><li><code>storage = Array</code> — Set to <code>CuArray</code> to use GPU.</li><li><code>Nbatch = 1</code> — Number of batches of data in this dataset.</li><li><code>μKarcminT = 3</code> — Noise level in temperature in μK-arcmin.</li><li><code>ℓknee = 100</code> — 1/f noise knee.</li><li><code>αknee = 3</code> — 1/f noise slope.</li><li><code>beamFWHM = 0</code> — Beam full-width-half-max in arcmin.</li><li><code>pixel_mask_kwargs = (;)</code> — NamedTuple of keyword arguments to pass to <code>make_mask</code> to create the pixel mask.</li><li><code>bandpass_mask = LowPass(3000)</code> — Operator which performs Fourier-space masking.</li><li><code>fiducial_θ = (;)</code> — NamedTuple of keyword arguments passed to <code>camb()</code> for the fiducial model.</li><li><code>seed = nothing</code> — Specific seed for the simulation.</li><li><code>L = LenseFlow</code> — Lensing operator.</li></ul><p>Returns a named tuple of <code>(;f, f̃, ϕ, n, ds, Cℓ, proj)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.resimulate" href="#CMBLensing.resimulate"><code>CMBLensing.resimulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre class="language-julia"><code class="language-julia">resimulate(ds::DataSet; [f, ϕ, n, f̃, rng, seed])</code></pre><p>Make a new DataSet with the data replaced by a simulation. Keyword argument fields will be used instead of new simulations, if they are provided. </p><p>Returns a named tuple of <code>(;ds, f, ϕ, n, f̃)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.resimulate!" href="#CMBLensing.resimulate!"><code>CMBLensing.resimulate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre class="language-julia"><code class="language-julia">resimulate!(ds::DataSet; [f, ϕ, n, f̃, rng, seed])</code></pre><p>Replace the data in this DataSet in-place with a simulation. Keyword argument fields will be used instead of new simulations, if they are provided. </p><p>Returns a named tuple of <code>(;ds, f, ϕ, n, f̃)</code>.</p></div></section></article><h2 id="Lensing-estimation-1"><a class="docs-heading-anchor" href="#Lensing-estimation-1">Lensing estimation</a><a class="docs-heading-anchor-permalink" href="#Lensing-estimation-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.MAP_joint" href="#CMBLensing.MAP_joint"><code>CMBLensing.MAP_joint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre class="language-julia"><code class="language-julia">MAP_joint(ds::DataSet; kwargs...)</code></pre><p>Compute the maximum a posteriori (i.e. &quot;MAP&quot;) estimate of the joint posterior, <span>$\mathcal{P}(f,\phi,\theta\,|\,d)$</span>, or compute a quasi-sample. </p><p>Keyword arguments:</p><ul><li><code>nsteps</code> — The maximum number of iterations for the maximizer.</li><li><code>ϕstart = 0</code> — Starting point of the maximizer.</li><li><code>ϕtol = nothing</code> — If given, stop when <code>ϕ</code> updates reach this tolerance. <code>ϕtol</code> is roughly the relative per-pixel standard deviation between changes to <code>ϕ</code> and draws from the <code>ϕ</code> prior. Values in the range <span>$10^{-2}-10^{-4}$</span> are reasonable. </li><li><code>nburnin_update_hessian = 10</code> — How many steps to wait before starting to do diagonal updates to the Hessian</li><li><code>conjgrad_kwargs = (;)</code> — Passed to the inner call to <a href="#CMBLensing.conjugate_gradient"><code>conjugate_gradient</code></a>.</li><li><code>progress = true</code> — Whether to show the progress bar.</li><li><code>Nϕ = :qe</code> — Noise to use in the initial approximation to the  Hessian. Can give <code>:qe</code> to use the quadratic estimate noise.</li><li><code>quasi_sample = false</code> — <code>false</code> to compute the MAP, <code>true</code> to  iterate quasi-samples, or an integer to compute a fixed-seed  quasi-sample.</li><li><code>history_keys</code> — What quantities to include in the returned <code>history</code>. Can be any subset of <code>(:f, :f°, :ϕ, :∇ϕ_lnP, :χ², :lnP)</code>.</li></ul><p>Returns a tuple <code>(f, ϕ, history)</code> where <code>f</code> is the best-fit (or quasi-sample) field, <code>ϕ</code> is the lensing potential, and <code>history</code> contains the history of steps during the run. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.MAP_marg" href="#CMBLensing.MAP_marg"><code>CMBLensing.MAP_marg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre class="language-julia"><code class="language-julia">MAP_marg(ds; kwargs...)</code></pre><p>Compute the maximum a posteriori (i.e. &quot;MAP&quot;) estimate of the marginal posterior, <span>$\mathcal{P}(\phi,\theta\,|\,d)$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.sample_joint" href="#CMBLensing.sample_joint"><code>CMBLensing.sample_joint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre class="language-julia"><code class="language-julia">sample_joint(ds::DataSet; kwargs...)</code></pre><p>Sample the joint posterior, <span>$\mathcal{P}(f,\phi,\theta\,|\,d)$</span>. </p><p>Keyword arguments: </p><ul><li><code>nsamps_per_chain</code> — The number of samples per chain.</li><li><code>nchains = 1</code> — Number of chains in parallel.</li><li><code>nchunk = 1</code> — Number of steps between parallel chain communication.</li><li><code>nsavemaps = 1</code> — Number of steps in between saving maps into chain.</li><li><code>nburnin_always_accept = 0</code> — Number of steps at the beginning of the chain to always accept HMC steps regardless of integration error.</li><li><code>nburnin_fixθ = 0</code> — Number of steps at the beginning of the chain before starting to sample <code>θ</code>.</li><li><code>Nϕ = :qe</code> — Noise to use in the initial approximation to the Hessian. Can give <code>:qe</code> to use the quadratic estimate noise.</li><li><code>chains = nothing</code> — <code>nothing</code> to start a new chain; the return value from a previous call to <code>sample_joint</code> to resume those chains; <code>:resume</code> to resume chains from a file given by <code>filename</code></li><li><code>θrange</code> — Range and density to grid sample parameters as a NamedTuple, e.g. <code>(Aϕ=range(0.7,1.3,length=20),)</code>. </li><li><code>θstart</code> — Starting values of parameters as a NamedTuple, e.g. <code>(Aϕ=1.2,)</code>, or nothing to randomly sample from θrange</li><li><code>ϕstart</code> — Starting <code>ϕ</code>, either a <code>Field</code> object, <code>:quasi_sample</code>, or <code>:best_fit</code></li><li><code>metadata</code> — Does nothing, but is saved into the chain file</li><li><code>nhmc = 1</code> — Number of HMC passes per <code>ϕ</code> Gibbs step.</li><li><code>symp_kwargs = fill((N=25, ϵ=0.01), nhmc)</code> — an array of NamedTupe kwargs to pass to <a href="#CMBLensing.symplectic_integrate-Union{Tuple{T}, Tuple{AbstractVector{T}, Any, Any, Any}, Tuple{AbstractVector{T}, Any, Any, Any, Any}} where T"><code>symplectic_integrate</code></a>. E.g. <code>[(N=50,ϵ=0.1),(N=25,ϵ=0.01)]</code> would do 50 large steps then 25 smaller steps per each Gibbs pass. If specified, <code>nhmc</code> is ignored.</li><li><code>wf_kwargs</code> — Keyword arguments to pass to <a href="#CMBLensing.argmaxf_lnP"><code>argmaxf_lnP</code></a> in the Wiener Filter Gibbs step.</li><li><code>MAP_kwargs</code> — Keyword arguments to pass to <a href="#CMBLensing.MAP_joint"><code>MAP_joint</code></a> when computing the starting point.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.argmaxf_lnP" href="#CMBLensing.argmaxf_lnP"><code>CMBLensing.argmaxf_lnP</code></a> — <span class="docstring-category">Function</span></header><section><div><pre class="language-julia"><code class="language-julia">argmaxf_lnP(ϕ,                ds::DataSet; kwargs...)
argmaxf_lnP(ϕ, θ, ds::DataSet; kwargs...)
argmaxf_lnP(Lϕ,               ds::DataSet; kwargs...)</code></pre><p>Computes either the Wiener filter at fixed <span>$\phi$</span>, or a sample from this slice along the posterior.</p><p>Keyword arguments: </p><ul><li><code>which</code> — <code>:wf</code>, <code>:sample</code>, or <code>fluctuation</code> to compute 1) the Wiener filter, i.e. the best-fit of <span>$\mathcal{P}(f\,|\,\phi,d)$</span>, 2) a sample from <span>$\mathcal{P}(f\,|\,\phi,d)$</span>, or 3) a sample minus the Wiener filter, i.e. the fluctuation on top of the mean.</li><li><code>fstart</code> — starting guess for <code>f</code> for the conjugate gradient solver</li><li><code>conjgrad_kwargs</code> — Passed to the inner call to <a href="#CMBLensing.conjugate_gradient"><code>conjugate_gradient</code></a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.quadratic_estimate" href="#CMBLensing.quadratic_estimate"><code>CMBLensing.quadratic_estimate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre class="language-julia"><code class="language-julia">quadratic_estimate(ds::DataSet, which; wiener_filtered=true)
quadratic_estimate((ds₁::DataSet, ds₂::DataSet), which; wiener_filtered=true)</code></pre><p>Compute the quadratic estimate of <code>ϕ</code> given data.</p><p>The <code>ds</code> or <code>(ds₁,ds₂)</code> tuple contain the DataSet object(s) which house the data and covariances used in the estimate. Note that only the Fourier-diagonal approximations for the beam, mask, and noise, i.e. <code>B̂</code>, <code>M̂</code>, and <code>Cn̂</code>, are accounted for. To account full operators (if they are not actually Fourier-diagonal), you should compute the impact using Monte Carlo.</p><p>If a tuple is passed in, the result will come from correlating the data from <code>ds₁</code> with that from <code>ds₂</code>.</p><p>An optional keyword argument <code>AL</code> can be passed in case the QE normalization was already computed, in which case it won&#39;t be recomputed during the calculation.</p><p>Returns a named tuple of <code>(;ϕqe, AL, Nϕ)</code> where <code>ϕqe</code> is the (possibly Wiener filtered, depending on <code>wiener_filtered</code> option) quadratic estimate, <code>AL</code> is the normalization (which is already applied to ϕqe, it does not need to be applied again), and <code>Nϕ</code> is the analytic N⁰ noise bias (Nϕ==AL if using unlensed weights, currently only Nϕ==AL is always returned, no matter the weights)</p></div></section></article><h2 id="Field-constructors-1"><a class="docs-heading-anchor" href="#Field-constructors-1">Field constructors</a><a class="docs-heading-anchor-permalink" href="#Field-constructors-1" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>FlatMap</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>FlatFourier</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>FlatQUMap</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>FlatQUFourier</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>FlatEBMap</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>FlatEBFourier</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>FlatIQUMap</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>FlatIQUFourier</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>FlatIEBMap</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>FlatIEBFourier</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Lensing-operators-1"><a class="docs-heading-anchor" href="#Lensing-operators-1">Lensing operators</a><a class="docs-heading-anchor-permalink" href="#Lensing-operators-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.LenseFlow" href="#CMBLensing.LenseFlow"><code>CMBLensing.LenseFlow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre class="language-julia"><code class="language-julia">LenseFlow(ϕ, [n=7])</code></pre><p><code>LenseFlow</code> is the ODE-based lensing algorithm from <a href="https://arxiv.org/abs/1708.06753">Millea, Anderes, &amp; Wandelt, 2019</a>. The number of steps in the ODE solver is controlled by <code>n</code>. The action of the operator, as well as its adjoint, inverse, inverse-adjoint, and gradient of any of these w.r.t. <code>ϕ</code> can all be computed. The log-determinant of the operation is zero independent of <code>ϕ</code>, in the limit of <code>n</code> high enough.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.BilinearLens" href="#CMBLensing.BilinearLens"><code>CMBLensing.BilinearLens</code></a> — <span class="docstring-category">Type</span></header><section><div><pre class="language-julia"><code class="language-julia">BilinearLens(ϕ)</code></pre><p><code>BilinearLens</code> is a lensing operator that computes lensing with bilinear interpolation. The action of the operator, as well as its adjoint, inverse, inverse-adjoint, and gradient w.r.t. <code>ϕ</code> can all be computed. The log-determinant of the operation is non-zero and can&#39;t be computed. </p><p>Internally, <code>BilinearLens</code> forms a sparse matrix with the interpolation weights, which can be applied and adjoint-ed extremely fast (e.g. at least an order of magnitude faster than <a href="#CMBLensing.LenseFlow"><code>LenseFlow</code></a>). Inverse and inverse-adjoint lensing is somewhat slower since it requires an iterative solve, here performed with the <a href="https://en.wikipedia.org/wiki/Generalized_minimal_residual_method">preconditioned generalized minimal residual</a> algorithm. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.Taylens" href="#CMBLensing.Taylens"><code>CMBLensing.Taylens</code></a> — <span class="docstring-category">Type</span></header><section><div><pre class="language-julia"><code class="language-julia">Taylens(ϕ, order)</code></pre><p><code>Taylens</code> is a lensing operator which lenses a map with a nearest-pixel permute step followed by power series expansion in the residual displacement, to any order. This is the algorithm from <a href="https://arxiv.org/abs/1307.0719">Næss&amp;Louis 2013</a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.PowerLens" href="#CMBLensing.PowerLens"><code>CMBLensing.PowerLens</code></a> — <span class="docstring-category">Type</span></header><section><div><pre class="language-julia"><code class="language-julia">PowerLens(ϕ, order)</code></pre><p><code>PowerLens</code> is a lensing operator which lenses a map with a power series expansion in <span>$\nabla \phi$</span> to any order. </p><div>\[f(x+\nabla x) \approx f(x) + (\nabla f)(\nabla \phi) + \frac{1}{2} (\nabla \nabla f) (\nabla \phi)^2 + ... \]</div><p>The action of the operator and its adjoint can be computed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.antilensing" href="#CMBLensing.antilensing"><code>CMBLensing.antilensing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre class="language-julia"><code class="language-julia">antilensing(L::PowerLens)</code></pre><p>Create a <code>PowerLens</code> operator that lenses by <code>-ϕ</code> instead. </p></div></section></article><h2 id="Configuration-options-1"><a class="docs-heading-anchor" href="#Configuration-options-1">Configuration options</a><a class="docs-heading-anchor-permalink" href="#Configuration-options-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.FFTW_NUM_THREADS" href="#CMBLensing.FFTW_NUM_THREADS"><code>CMBLensing.FFTW_NUM_THREADS</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>The number of threads used by FFTW for CPU FFTs (default is the environment variable <code>FFTW_NUM_THREADS</code>, or if that is not specified its <code>Sys.CPU_THREADS÷2</code>). This must be set before creating any <code>FlatField</code> objects.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.FFTW_TIMELIMIT" href="#CMBLensing.FFTW_TIMELIMIT"><code>CMBLensing.FFTW_TIMELIMIT</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Time-limit for FFT planning on CPU (default: 5 seconds). This must be set before creating any <code>FlatField</code> objects.</p></div></section></article><h2 id="Other-1"><a class="docs-heading-anchor" href="#Other-1">Other</a><a class="docs-heading-anchor-permalink" href="#Other-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.batch-Union{Tuple{Vararg{BaseField{B, M, T, A} where {M&lt;:ProjLambert, T, A&lt;:(AbstractArray{T, N} where N)}, N} where N}, Tuple{B}} where B" href="#CMBLensing.batch-Union{Tuple{Vararg{BaseField{B, M, T, A} where {M&lt;:ProjLambert, T, A&lt;:(AbstractArray{T, N} where N)}, N} where N}, Tuple{B}} where B"><code>CMBLensing.batch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">batch(fs::LambertField...)
batch(fs::Vector{&lt;:LambertField})</code></pre><p>Concatenate one of more LambertFields along the &quot;batch&quot; dimension (dimension 4 of the underlying array). For the inverse operation, see <a href="#CMBLensing.unbatch-Tuple{CMBLensing.Chains}"><code>unbatch</code></a>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.beamCℓs-Tuple{}" href="#CMBLensing.beamCℓs-Tuple{}"><code>CMBLensing.beamCℓs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">beamCℓs(;beamFWHM, ℓmax=8000)</code></pre><p>Compute the beam power spectrum, often called <span>$W_\ell$</span>. A map should be multiplied by the square root of this.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.cpu-Tuple{Any}" href="#CMBLensing.cpu-Tuple{Any}"><code>CMBLensing.cpu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">cpu(x)</code></pre><p>Recursively move an object to CPU memory. See also <a href="#CMBLensing.gpu"><code>gpu</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.get_max_lensing_step-Tuple{Any, Any}" href="#CMBLensing.get_max_lensing_step-Tuple{Any, Any}"><code>CMBLensing.get_max_lensing_step</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns αmax such that 𝕀 + ∇∇(ϕ + α * η) has non-zero discriminant (pixel-by-pixel) for all α values in [0, αmax]. </p><p>This mean ϕ + αmax * η is the maximum step in the η direction which can be added to ϕ and still yield a lensing potential in the weak-lensing regime. This is important because it guarantees the potential can be paseed to LenseFlow, which cannot handle the strong-lensing / &quot;shell-crossing&quot; regime.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.gradhess-Tuple{Any}" href="#CMBLensing.gradhess-Tuple{Any}"><code>CMBLensing.gradhess</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">gradhess(f)</code></pre><p>Compute the gradient <span>$g^i = \nabla^i f$</span>, and the hessian, <span>$H_j^{\,i} = \nabla_j \nabla^i f$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.kde-Tuple{AbstractVector{T} where T}" href="#CMBLensing.kde-Tuple{AbstractVector{T} where T}"><code>CMBLensing.kde</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">kde(samples::AbstractVector; [boundary=(min,max), normalize=&quot;integral&quot; or &quot;max&quot;])
kde(samples::AbstractMatrix; [boundary=[(min1,max1),(min2,max2)], normalize=&quot;integral&quot; or &quot;max&quot;, smooth_scale_2D])</code></pre><p>Return a Kernel Density Estimate for a set of 1D or 2D samples. The return object is a function which can be evaluated anywhere to compute the PDF. If provided, <code>boundary</code> specifies a hard upper/lower bound for the 1 or 2 or parameters, <code>normalize</code> specifies whether to normalize the PDF to unit integral or unit maximum, and <code>smooth_scale_2D</code> specifies how much smoothing to do for the 2D case.</p><p>Based on Python <a href="https://getdist.readthedocs.io/en/latest/intro.html">GetDist</a>,  which must be installed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.lnP-Tuple{Any, Any, Any, DataSet}" href="#CMBLensing.lnP-Tuple{Any, Any, Any, DataSet}"><code>CMBLensing.lnP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">lnP(t, fₜ, ϕₜ,    ds::DataSet)
lnP(t, fₜ, ϕₜ, θ, ds::DataSet)</code></pre><p>Compute the log posterior probability in the joint parameterization as a function of the field, <span>$f_t$</span>, the lensing potential, <span>$\phi_t$</span>, and possibly some cosmological parameters, <span>$\theta$</span>. The subscript <span>$t$</span> can refer to either a &quot;time&quot;, e.g. passing <code>t=0</code> corresponds to the unlensed parametrization and <code>t=1</code> to the lensed one, or can be <code>:mix</code> correpsonding to the mixed parametrization. In all cases, the arguments <code>fₜ</code> and <code>ϕₜ</code> should then be <span>$f$</span> and <span>$\phi$</span> in that particular parametrization.</p><p>If any parameters <span>$\theta$</span> are provided, we also include the determinant terms for covariances which depend on <span>$\theta$</span>. In the mixed parametrization, we also include any Jacobian determinant terms that depend on <span>$\theta$</span>. </p><p>The argument <code>ds</code> should be a <code>DataSet</code> and stores the masks, data, etc... needed to construct the posterior. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.load_camb_Cℓs-Tuple{}" href="#CMBLensing.load_camb_Cℓs-Tuple{}"><code>CMBLensing.load_camb_Cℓs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">load_camb_Cℓs(;path_prefix, custom_tensor_params=nothing, 
    unlensed_scalar_postfix, unlensed_tensor_postfix, lensed_scalar_postfix, lenspotential_postfix)</code></pre><p>Load some Cℓs from CAMB files. </p><p><code>path_prefix</code> specifies the prefix for the files, which are then expected to have the normal CAMB postfixes: <code>scalCls.dat</code>, <code>tensCls.dat</code>, <code>lensedCls.dat</code>, <code>lenspotentialCls.dat</code>, unless otherwise specified via the other keyword arguments. <code>custom_tensor_params</code> can be used to call CAMB directly for the <code>unlensed_tensors</code>, rather than reading them from a file (since alot of times this file doesn&#39;t get saved). The value should be a Dict/NamedTuple which will be passed to a call to <a href="@ref"><code>camb</code></a>, e.g. <code>custom_tensor_params=(r=0,)</code> for zero tensors. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.load_chains-Tuple{Any}" href="#CMBLensing.load_chains-Tuple{Any}"><code>CMBLensing.load_chains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">load_chains(filename; burnin=0, burnin_chunks=0, thin=1, join=false, unbatch=true)</code></pre><p>Load a single chain or multiple parallel chains which were written to a file by <a href="#CMBLensing.sample_joint"><code>sample_joint</code></a>. </p><p>Keyword arguments: </p><ul><li><code>burnin</code> — Remove this many samples from the start of each chain, or if negative, keep only this many samples at the end of each chain.</li><li><code>burnin_chunks</code> — Same as burnin, but in terms of chain &quot;chunks&quot; stored in the chain file, rather than in terms of samples.</li><li><code>thin</code> — If <code>thin</code> is an integer, thin the chain by this factor. If <code>thin == :hasmaps</code>, return only samples which have maps saved. If thin is a <code>Function</code>, filter the chain by this function (e.g. <code>thin=haskey(:g)</code> on Julia 1.5+)</li><li><code>unbatch</code> — If true, <a href="@ref">unbatch</a> the chains if they are batched.</li><li><code>join</code> — If true, concatenate all the chains together.</li><li><code>skip_missing_chunks</code> — Skip missing chunks in the chain instead of terminating the chain there. </li></ul><p>The object returned by this function is a <code>Chain</code> or <code>Chains</code> object, which simply wraps an <code>Array</code> of <code>Dicts</code> or an <code>Array</code> of <code>Array</code> of <code>Dicts</code>, respectively (each sample is a <code>Dict</code>). The wrapper object has some extra indexing properties for convenience: </p><ul><li>It can be indexed as if it were a single multidimensional object, e.g. <code>chains[1,:,:accept]</code> would return the <code>:accept</code> key of all samples in the first chain.</li><li>Leading colons can be dropped, i.e. <code>chains[:,:,:accept]</code> is the same as <code>chains[:accept]</code>. </li><li>If some samples are missing a particular key, <code>missing</code> is returned for those samples insted of an error.</li><li>The recursion goes arbitrarily deep into the objects it finds. E.g., since sampled parameters are stored in a <code>NamedTuple</code> like <code>(Aϕ=1.3,)</code> in the <code>θ</code> key of each sample <code>Dict</code>, you can do <code>chain[:θ,:Aϕ]</code> to get all <code>Aϕ</code> samples as a vector. </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.mean_std_and_errors-Tuple{Any}" href="#CMBLensing.mean_std_and_errors-Tuple{Any}"><code>CMBLensing.mean_std_and_errors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">mean_std_and_errors(samples; N_bootstrap=10000)</code></pre><p>Get the mean and standard deviation of a set of correlated <code>samples</code> from a chain where the error on the mean and standard deviation is estimated with bootstrap resampling using the calculated &quot;effective sample size&quot; of the chain.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.mix-Tuple{Any, Any, DataSet}" href="#CMBLensing.mix-Tuple{Any, Any, DataSet}"><code>CMBLensing.mix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">mix(f, ϕ,    ds::DataSet)
mix(f, ϕ, θ, ds::DataSet)</code></pre><p>Compute the mixed <code>(f°, ϕ°)</code> from the unlensed field <code>f</code> and lensing potential <code>ϕ</code>, given the definition of the mixing matrices in <code>ds</code> evaluated at parameters <code>θ</code> (or at fiducial values if no <code>θ</code> provided).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.noiseCℓs-Tuple{}" href="#CMBLensing.noiseCℓs-Tuple{}"><code>CMBLensing.noiseCℓs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">noiseCℓs(;μKarcminT, beamFWHM=0, ℓmax=8000, ℓknee=100, αknee=3)</code></pre><p>Compute the (:TT,:EE,:BB,:TE) noise power spectra given white noise + 1/f. Polarization noise is scaled by <span>$\sqrt{2}$</span> relative to <code>μKarcminT</code>. <code>beamFWHM</code> is in arcmin.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.pixwin-Tuple{Any, Any}" href="#CMBLensing.pixwin-Tuple{Any, Any}"><code>CMBLensing.pixwin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">pixwin(θpix, ℓ)</code></pre><p>Returns the pixel window function for square flat-sky pixels of width <code>θpix</code> (in arcmin) evaluated at some <code>ℓ</code>s. This is the scaling of k-modes, the scaling of the power spectrum will be pixwin^2. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.project-Tuple{Pair{var&quot;#s160&quot;, var&quot;#s159&quot;} where {var&quot;#s160&quot;&lt;:(BaseField{B, M, T, A} where {B&lt;:CMBLensing.S0Basis, M&lt;:CMBLensing.CartesianProj, T, A&lt;:(AbstractArray{T, N} where N)}), var&quot;#s159&quot;&lt;:ProjHealpix}}" href="#CMBLensing.project-Tuple{Pair{var&quot;#s160&quot;, var&quot;#s159&quot;} where {var&quot;#s160&quot;&lt;:(BaseField{B, M, T, A} where {B&lt;:CMBLensing.S0Basis, M&lt;:CMBLensing.CartesianProj, T, A&lt;:(AbstractArray{T, N} where N)}), var&quot;#s159&quot;&lt;:ProjHealpix}}"><code>CMBLensing.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">project(flat_map::FlatField =&gt; healpix_proj::ProjHealpix; [rotator])</code></pre><p>Reproject a <code>flat_map</code> back onto the sphere in a Healpix projection specified by <code>healpix_proj</code>. E.g.</p><pre class="language-none"><code class="language-none">flat_map = FlatMap(rand(128,128))
f = project(flat_map =&gt; ProjHealpix(2048); rotator=pyimport(&quot;healpy&quot;).Rotator((0,28,23)))</code></pre><p>The use of <code>=&gt;</code> is to help remember in which order the arguments are specified. Optional keyword argument <code>rotator</code> is a <code>healpy.Rotator</code> object specifying a rotation which rotates the north pole to the center of the desired field. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.project-Tuple{Pair{var&quot;#s195&quot;, var&quot;#s161&quot;} where {var&quot;#s195&quot;&lt;:(BaseField{Map, M, T, A} where {M&lt;:ProjHealpix, T, A&lt;:(AbstractArray{T, N} where N)}), var&quot;#s161&quot;&lt;:CMBLensing.CartesianProj}}" href="#CMBLensing.project-Tuple{Pair{var&quot;#s195&quot;, var&quot;#s161&quot;} where {var&quot;#s195&quot;&lt;:(BaseField{Map, M, T, A} where {M&lt;:ProjHealpix, T, A&lt;:(AbstractArray{T, N} where N)}), var&quot;#s161&quot;&lt;:CMBLensing.CartesianProj}}"><code>CMBLensing.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">project(healpix_map::HealpixField =&gt; cart_proj::CartesianProj)</code></pre><p>Project <code>healpix_map</code> to a cartisian projection specified by <code>cart_proj</code>. E.g.:</p><pre class="language-none"><code class="language-none">healpix_map = HealpixMap(rand(12*2048^2))
flat_proj = ProjLambert(Ny=128, Nx=128, θpix=3, T=Float32)
f = project(healpix_map =&gt; flat_proj; rotator=pyimport(&quot;healpy&quot;).Rotator((0,28,23)))</code></pre><p>The use of <code>=&gt;</code> is to help remember in which order the arguments are specified. If <code>healpix_map</code> is a <code>HealpixQU</code>, Q/U polarization angles are rotated to be aligned with the local coordinates (sometimes called &quot;polarization flattening&quot;).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.simulate-Tuple{Any}" href="#CMBLensing.simulate-Tuple{Any}"><code>CMBLensing.simulate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">simulate(Σ; rng=global_rng_for(Σ), seed=nothing)</code></pre><p>Draw a simulation from the covariance matrix <code>Σ</code>, i.e. draw a random vector <span>$\xi$</span> such that the covariance <span>$\langle \xi \xi^\dagger \rangle = \Sigma$</span>. </p><p>The random number generator <code>rng</code> will be used and advanced in the proccess, and is by default the appropriate one depending on if <code>Σ</code> is backed by <code>Array</code> or <code>CuArray</code>.</p><p>The <code>seed</code> argument can also be used to seed the <code>rng</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.symplectic_integrate-Union{Tuple{T}, Tuple{AbstractVector{T}, Any, Any, Any}, Tuple{AbstractVector{T}, Any, Any, Any, Any}} where T" href="#CMBLensing.symplectic_integrate-Union{Tuple{T}, Tuple{AbstractVector{T}, Any, Any, Any}, Tuple{AbstractVector{T}, Any, Any, Any, Any}} where T"><code>CMBLensing.symplectic_integrate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">symplectic_integrate(x₀, p₀, Λ, U, δUδx, N=50, ϵ=0.1, progress=false)</code></pre><p>Do a symplectic integration of the potential energy <code>U</code> (with gradient <code>δUδx</code>) starting from point <code>x₀</code> with momentum <code>p₀</code> and mass matrix <code>Λ</code>. The number of steps is <code>N</code> and the step size <code>ϵ</code>. </p><p>Returns <code>ΔH, xᵢ, pᵢ</code> corresponding to change in Hamiltonian, and final position and momenta. If <code>history_keys</code> is specified a history of requested variables throughout each step is also returned. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.ud_grade-Union{Tuple{B}, Tuple{BaseField{B, M, T, A} where {M&lt;:ProjLambert, T, A&lt;:(AbstractArray{T, N} where N)}, Any}} where B" href="#CMBLensing.ud_grade-Union{Tuple{B}, Tuple{BaseField{B, M, T, A} where {M&lt;:ProjLambert, T, A&lt;:(AbstractArray{T, N} where N)}, Any}} where B"><code>CMBLensing.ud_grade</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">ud_grade(f::Field, θnew, mode=:map, deconv_pixwin=true, anti_aliasing=true)</code></pre><p>Up- or down-grades field <code>f</code> to new resolution <code>θnew</code> (only in integer steps). Two modes are available specified by the <code>mode</code> argument: </p><ul><li><code>:map</code>     — Up/downgrade by replicating/averaging pixels in map-space</li><li><code>:fourier</code> — Up/downgrade by extending/truncating the Fourier grid</li></ul><p>For <code>:map</code> mode, two additional options are possible. If <code>deconv_pixwin</code> is true, deconvolves the pixel window function from the downgraded map so the spectrum of the new and old maps are the same. If <code>anti_aliasing</code> is true, filters out frequencies above Nyquist prior to down-sampling. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.unbatch-Tuple{CMBLensing.Chains}" href="#CMBLensing.unbatch-Tuple{CMBLensing.Chains}"><code>CMBLensing.unbatch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">unbatch(chains::Chains)</code></pre><p>Expand each chain in this <code>Chains</code> object by unbatching it. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.unbatch-Tuple{CMBLensing.Chain}" href="#CMBLensing.unbatch-Tuple{CMBLensing.Chain}"><code>CMBLensing.unbatch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">unbatch(chain::Chain)</code></pre><p>Convert a chain of batch-length-<code>D</code> fields to <code>D</code> chains of unbatched fields. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.unbatch-Union{Tuple{BaseField{B, M, T, A} where {M&lt;:ProjLambert, T, A&lt;:(AbstractArray{T, N} where N)}}, Tuple{B}} where B" href="#CMBLensing.unbatch-Union{Tuple{BaseField{B, M, T, A} where {M&lt;:ProjLambert, T, A&lt;:(AbstractArray{T, N} where N)}}, Tuple{B}} where B"><code>CMBLensing.unbatch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">unbatch(f::LambertField)</code></pre><p>Return an Array of LambertFields corresponding to each batch index. For the inverse operation, see <a href="#CMBLensing.batch-Union{Tuple{Vararg{BaseField{B, M, T, A} where {M&lt;:ProjLambert, T, A&lt;:(AbstractArray{T, N} where N)}, N} where N}, Tuple{B}} where B"><code>batch</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.unmix-Tuple{Any, Any, DataSet}" href="#CMBLensing.unmix-Tuple{Any, Any, DataSet}"><code>CMBLensing.unmix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">unmix(f°, ϕ°,    ds::DataSet)
unmix(f°, ϕ°, θ, ds::DataSet)</code></pre><p>Compute the unmixed/unlensed <code>(f, ϕ)</code> from the mixed field <code>f°</code> and mixed lensing potential <code>ϕ°</code>, given the definition of the mixing matrices in <code>ds</code> evaluated at parameters <code>θ</code> (or at fiducial values if no <code>θ</code> provided). </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.ParamDependentOp" href="#CMBLensing.ParamDependentOp"><code>CMBLensing.ParamDependentOp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre class="language-julia"><code class="language-julia">ParamDependentOp(recompute_function::Function)</code></pre><p>Creates an operator which depends on some parameters <span>$\theta$</span> and can be evaluated at various values of these parameters. </p><p><code>recompute_function</code> should be a function which accepts keyword arguments for <span>$\theta$</span> and returns the operator. Each keyword must have a default value; the operator will act as if evaluated at these defaults unless it is explicitly evaluated at other parameters. </p><p>Example:</p><pre class="language-julia"><code class="language-julia">Cϕ₀ = Diagonal(...) # some fixed Diagonal operator
Cϕ = ParamDependentOp((;Aϕ=1)-&gt;Aϕ*Cϕ₀) # create ParamDependentOp

Cϕ(Aϕ=1.1) * ϕ   # Cϕ(Aϕ=1.1) is equal to 1.1*Cϕ₀
Cϕ * ϕ           # Cϕ alone will act like Cϕ(Aϕ=1) because that was the default above</code></pre><p>Note: if you are doing parallel work, global variables referred to in the <code>recompute_function</code> need to be distributed to all workers. A more robust solution is to avoid globals entirely and instead ensure all variables are &quot;closed&quot; over (and hence will automatically get distributed). This will happen by default if defining the <code>ParamDependentOp</code> inside any function, or can be forced at the global scope by wrapping everything in a <code>let</code>-block, e.g.:</p><pre class="language-julia"><code class="language-julia">Cϕ = let Cϕ₀=Cϕ₀
    ParamDependentOp((;Aϕ=1)-&gt;Aϕ*Cϕ₀)
end</code></pre><p>After executing the code above, <code>Cϕ</code> is now ready to be (auto-)shipped to any workers and will work regardless of what global variables are defined on these workers. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.ProjEquiRect-Tuple{}" href="#CMBLensing.ProjEquiRect-Tuple{}"><code>CMBLensing.ProjEquiRect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">ProjEquiRect(; Ny::Int, Nx::Int, θspan::Tuple, φspan::Tuple,         T=Float32, storage=Array)
ProjEquiRect(; θ::Vector, φ::Vector, θedges::Vector, φedges::Vector, T=Float32, storage=Array)</code></pre><p>Construct an EquiRect projection object. The projection can either be specified by:</p><ul><li>The number of pixels <code>Ny</code> and <code>Nx</code> (corresponding to the <code>θ</code> and <code>φ</code> angular directions, respectively) and the span in radians of the field in these directions, <code>θspan</code> and <code>φspan</code>. The order in which the span tuples are given is irrelevant, either order will refer to the same field. Note, the spans correspond to the field size between outer pixel edges, not from pixel centers. If one wishes to call <a href="@ref"><code>Cℓ_to_Cov</code></a> with this projection, <code>φspan</code> must be an integer multiple of 2π, but other functionality will be available if this is not the case. </li><li>A manual list of pixels centers and pixel edges, <code>θ</code>, <code>φ</code>, <code>θedges</code>, <code>φedges</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.RK4Solver-Tuple{Function, Any, Any, Any, Any}" href="#CMBLensing.RK4Solver-Tuple{Function, Any, Any, Any, Any}"><code>CMBLensing.RK4Solver</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">RK4Solver(F!::Function, y₀, t₀, t₁, nsteps)</code></pre><p>Solve for <span>$y(t_1)$</span> with 4th order Runge-Kutta assuming <span>$dy/dt = F(t,y)$</span> and <span>$y(t_0)$</span> = <span>$y_0$</span>.</p><p>Arguments:</p><ul><li><code>F!</code> — a function <code>F!(v,t,y)</code><code>which sets</code>v=F(t,y)`</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.@cpu!-Tuple" href="#CMBLensing.@cpu!-Tuple"><code>CMBLensing.@cpu!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre class="language-julia"><code class="language-julia">@cpu! x y</code></pre><p>Equivalent to <code>x = cpu(x)</code>, <code>y = cpu(y)</code>, etc... for any number of listed variables. See <a href="#CMBLensing.cpu-Tuple{Any}"><code>cpu</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.@ismain-Tuple{}" href="#CMBLensing.@ismain-Tuple{}"><code>CMBLensing.@ismain</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre class="language-julia"><code class="language-julia">@ismain()</code></pre><p>Return true if the current file is being run as a script.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.@repeated-Tuple{Any, Any}" href="#CMBLensing.@repeated-Tuple{Any, Any}"><code>CMBLensing.@repeated</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Return a tuple with the expression repeated n times </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.@show⌛-Tuple{Any}" href="#CMBLensing.@show⌛-Tuple{Any}"><code>CMBLensing.@show⌛</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>See <a href="#CMBLensing.@⌛-Tuple"><code>@⌛</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.@⌛-Tuple" href="#CMBLensing.@⌛-Tuple"><code>CMBLensing.@⌛</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre class="language-julia"><code class="language-julia">@⌛ [label] code ...
@⌛ [label] function_definition() = ....</code></pre><p>Label a section of code to be timed. If a label string is not provided, the first form uses the code itselfs as a label, the second uses the function name, and its the body of the function which is timed. </p><p>To run the timer and print output, returning the result of the calculation, use</p><pre class="language-none"><code class="language-none">@show⌛ run_code()</code></pre><p>Timing uses <code>TimerOutputs.get_defaulttimer()</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.Jperm-Tuple{Int64, Int64}" href="#CMBLensing.Jperm-Tuple{Int64, Int64}"><code>CMBLensing.Jperm</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Jperm(ℓ::Int, n::Int) return the column number in the J matrix U^2 where U is unitary FFT. The J matrix looks like this:</p><p>|1   0| |  / 1| | / / | |0 1  |</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.LinearInterpolation-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}" href="#CMBLensing.LinearInterpolation-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}"><code>CMBLensing.LinearInterpolation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">itp = LinearInterpolation(xdat::AbstractVector, ydat::AbstractVector; extrapolation_bc=NaN)
itp(x) # interpolate at x</code></pre><p>A simple 1D linear interpolation code which is fully Zygote differentiable in either <code>xdat</code>, <code>ydat</code>, or the evaluation point <code>x</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.QE_leg-Tuple{Diagonal, Vararg{Any, N} where N}" href="#CMBLensing.QE_leg-Tuple{Diagonal, Vararg{Any, N} where N}"><code>CMBLensing.QE_leg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">QE_leg(C::Diagonal, inds...)</code></pre><p>The quadratic estimate and normalization expressions all consist of terms involving products of two &quot;legs&quot;, each leg which look like:</p><pre class="language-none"><code class="language-none">C * l[i] * l̂[j] * l̂[k] * ...</code></pre><p>where C is some field or diagonal covariance, l[i] is the Fourier wave-vector in direction i (for i=1:2), and l̂[i] = l[i]/‖l‖. For example, there&#39;s a leg in the EB estimator that looks like: </p><pre class="language-none"><code class="language-none">(CE * (CẼ+Cn) \ d[:E])) * l[i] * l̂[j] * l̂[k]</code></pre><p>The function <code>QE_leg</code> computes quatities like these, e.g. the above would be given by:</p><pre class="language-none"><code class="language-none">QE_leg((CE * (CẼ+Cn) \ d[:E])), [i], j, k)</code></pre><p>(where note that specifying whether its the Fourier wave-vector l instead of the unit-vector l̂ is done by putting that index in brackets).</p><p>Additionally, all of these terms are symmetric in their indices, i.e. in <code>(i,j,k)</code> in this case. The <code>QE_leg</code> function is smart about this, and is memoized so that each unique set of indices is only computed once. This leads to a pretty drastic speedup for terms with many indices like those that arize in the EE and EB normalizations, and lets us write code which is both clear and fast without having to think too hard about these symmetries.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.assign_GPU_workers-Tuple{}" href="#CMBLensing.assign_GPU_workers-Tuple{}"><code>CMBLensing.assign_GPU_workers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">assign_GPU_workers()</code></pre><p>Assign each Julia worker process a unique GPU using <code>CUDA.device!</code>. Workers may be distributed across different hosts, and each host can have multiple GPUs.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.conjugate_gradient" href="#CMBLensing.conjugate_gradient"><code>CMBLensing.conjugate_gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre class="language-julia"><code class="language-julia">conjugate_gradient(
    M, A, b, x=M\b; 
    nsteps       = length(b), 
    tol          = sqrt(eps()), 
    progress     = false, 
    callback     = nothing, 
    history_keys = nothing, 
    history_mod  = 1
)</code></pre><p>Compute <code>x=A\b</code> (where <code>A</code> is positive definite) by conjugate gradient. <code>M</code> is the preconditioner and should be <code>M≈A</code>, and <code>M\x</code> should be fast.</p><p>The solver will stop either after <code>nsteps</code> iterations or when <code>dot(r,r)&lt;tol</code> (where <code>r=A*x-b</code> is the residual  at that step), whichever occurs first.</p><p>Info from the iterations of the solver can be returned if <code>history_keys</code> is specified. <code>history_keys</code> can be one or a tuple of:</p><ul><li><code>:i</code> — current iteration number</li><li><code>:x</code> — current solution</li><li><code>:r</code> — current residual <code>r=A*x-b</code></li><li><code>:res</code> — the norm of <code>r</code></li><li><code>:t</code> — the time elapsed (in seconds) since the start of the algorithm</li></ul><p><code>history_mod</code> can be used to include every N-th iteration only in <code>history_keys</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.fftsyms-Union{Tuple{n}, Tuple{m}, Tuple{Val{m}, Val{n}}} where {m, n}" href="#CMBLensing.fftsyms-Union{Tuple{n}, Tuple{m}, Tuple{Val{m}, Val{n}}} where {m, n}"><code>CMBLensing.fftsyms</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Arguments <code>m</code> and <code>n</code> refer to the sizes of an <code>m</code>×<code>n</code> matrix (call it <code>A</code>) that is the output of a real FFT (thus <code>m=n÷2+1</code>)</p><p>Returns a tuple of (ireal, iimag, negks) where these are</p><ul><li><code>ireal</code> — <code>m</code>×<code>n</code> mask corrsponding to unique real entries of <code>A</code></li><li><code>iimag</code> — <code>m</code>×<code>n</code> mask corrsponding to unique imaginary entries of <code>A</code></li><li><code>negks</code> — <code>m</code>×<code>n</code> matrix of giving the index into A where the negative k-vector           is, s.t. <code>A[i,j] = A[negks[i,j]]&#39;</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.fieldvalues-Tuple{Any}" href="#CMBLensing.fieldvalues-Tuple{Any}"><code>CMBLensing.fieldvalues</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the type&#39;s fields as a tuple</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.finite_second_derivative-Tuple{Any}" href="#CMBLensing.finite_second_derivative-Tuple{Any}"><code>CMBLensing.finite_second_derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">finite_second_derivative(x)</code></pre><p>Second derivative of a vector <code>x</code> via finite differences, including at end points.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.gmres-Tuple{Any, Any}" href="#CMBLensing.gmres-Tuple{Any, Any}"><code>CMBLensing.gmres</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">gmres(A, b; maxiter, Pl=I)</code></pre><p>Solve <code>A \ b</code> with <code>maxiter</code> iterations of the <a href="https://en.wikipedia.org/wiki/Generalized_minimal_residual_method">generalized minimal residual</a> algorithm. <code>Pl</code> is a left-preconditioner which should approximate <code>inv(A)</code>. </p><p>Note: the implemenation is memory inefficient and uses O(n * maxiter) memory, where <code>n,n=size(A)</code> (may not be a big deal for small <code>maxiter</code>), although is totally generic and works with CPU or GPU and dense or sparse matrices, unlike IterativeSolver&#39;s <code>gmres</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.gpu" href="#CMBLensing.gpu"><code>CMBLensing.gpu</code></a> — <span class="docstring-category">Function</span></header><section><div><pre class="language-julia"><code class="language-julia">gpu(x)</code></pre><p>Recursively move an object to GPU memory. Note that, unlike <code>cu(x)</code>, this does not change the <code>eltype</code> of any underlying arrays. See also <a href="#CMBLensing.cpu-Tuple{Any}"><code>cpu</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.grid_and_sample-Tuple{Function, AbstractVector{T} where T}" href="#CMBLensing.grid_and_sample-Tuple{Function, AbstractVector{T} where T}"><code>CMBLensing.grid_and_sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">grid_and_sample(lnP::Function; range::NamedTuple; progress=false, nsamples=1)</code></pre><p>Interpolate the log pdf <code>lnP</code> with support on <code>range</code>, and return  the integrated log pdf as well <code>nsamples</code> samples (drawn via inverse transform sampling)</p><p><code>lnP</code> should either accept a NamedTuple argument and <code>range</code> should be a NamedTuple mapping those same names to <code>range</code> objects specifying where to evaluate <code>lnP</code>, e.g.:</p><pre class="language-julia"><code class="language-julia">grid_and_sample(nt-&gt;-(nt.x^2+nt.y^2)/2, (x=range(-3,3,length=100),y=range(-3,3,length=100)))</code></pre><p>or <code>lnP</code> should accept a single scalar argument and <code>range</code> should be directly the range for this variable:</p><pre class="language-julia"><code class="language-julia">grid_and_sample(x-&gt;-x^2/2, range(-3,3,length=100))</code></pre><p>The return value is <code>(lnP, samples, Px)</code> where <code>lnP</code> is an interpolated/smoothed log PDF which can be evaluated anywhere within the original range, <code>Px</code> are sampled points of the original PDF, and <code>samples</code> is a NamedTuple giving the Monte-Carlo samples of each of the parameters.</p><p>(Note: only 1D sampling is currently implemented, but 2D like in the example above is planned)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.lazy_pyimport-Tuple{Any}" href="#CMBLensing.lazy_pyimport-Tuple{Any}"><code>CMBLensing.lazy_pyimport</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">lazy_pyimport(s)</code></pre><p>Like <code>pyimport(s)</code>, but doesn&#39;t actually load anything (not even PyCall) until a property of the returned module is accessed, allowing this to go in <code>__init__</code> and still delay loading PyCall, as well as preventing a Julia module load error if a Python module failed to load.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.longest_run_of_trues-Tuple{Any}" href="#CMBLensing.longest_run_of_trues-Tuple{Any}"><code>CMBLensing.longest_run_of_trues</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">longest_run_of_trues(x)</code></pre><p>The slice corresponding to the longest run of <code>true</code>s in the vector <code>x</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.paren_errors-Tuple{Any, Any}" href="#CMBLensing.paren_errors-Tuple{Any, Any}"><code>CMBLensing.paren_errors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">paren_errors(μ, σ; N_in_paren=2)</code></pre><p>Get a string represntation of <code>μ ± σ</code> in &quot;parenthesis&quot; format, e.g. <code>1.234 ± 0.012</code> becomes <code>1.234(12)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.proc_info-Tuple{}" href="#CMBLensing.proc_info-Tuple{}"><code>CMBLensing.proc_info</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">proc_info()</code></pre><p>Returns string showing info about available processes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.rfft2vec-Tuple{AbstractMatrix{T} where T}" href="#CMBLensing.rfft2vec-Tuple{AbstractMatrix{T} where T}"><code>CMBLensing.rfft2vec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert a matrix A which is the output of a real FFT to a real vector, keeping only unqiue real/imaginary entries of A</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.rfft_degeneracy_fac-Tuple{Any}" href="#CMBLensing.rfft_degeneracy_fac-Tuple{Any}"><code>CMBLensing.rfft_degeneracy_fac</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">rfft_degeneracy_fac(n)</code></pre><p>Returns an Array which is 2 if the complex conjugate of the corresponding entry in the half-plane real FFT appears in the full-plane FFT, and is 1 othewise. <code>n</code> is the length of the first dimension of the full-plane FFT. The following identity holds:</p><pre class="language-none"><code class="language-none">sum(abs2.(fft(x)) = sum(rfft_degeneracy_fac(size(x,1)) .* abs2.(rfft(x))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.set_distributed_dataset" href="#CMBLensing.set_distributed_dataset"><code>CMBLensing.set_distributed_dataset</code></a> — <span class="docstring-category">Function</span></header><section><div><pre class="language-julia"><code class="language-julia">set_distributed_dataset(ds, [storage])
get_distributed_dataset()</code></pre><p>Sometimes it&#39;s more performant to distribute a DataSet object to parallel workers just once, and have them refer to it from the global state, rather than having it get automatically but repeatedly sent as part of closures. This provides that functionality. Use <code>set_distributed_dataset(ds)</code> from the master process to set the global DataSet and <code>get_distributed_dataset()</code> from any process to retrieve it. Repeated calls will not resend <code>ds</code> if it hasn&#39;t changed (based on <code>hash(ds)</code>) and if no new workers have been added since the last send. The optional argument <code>storage</code> will also adapt the dataset to a particular storage on the workers, and can be a symbol, e.g. <code>:CuArray</code>, in the case that CUDA is not loaded on the master process.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.unfold-Tuple{AbstractArray{var&quot;#s34&quot;, 3} where var&quot;#s34&quot;, Any}" href="#CMBLensing.unfold-Tuple{AbstractArray{var&quot;#s34&quot;, 3} where var&quot;#s34&quot;, Any}"><code>CMBLensing.unfold</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert an M×N matrix (with M=N÷2+1) which is the output a real FFT to a full N×N one via symmetries.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.vec2rfft-Tuple{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#CMBLensing.vec2rfft-Tuple{AbstractVector{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>CMBLensing.vec2rfft</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert a vector produced by rfft2vec back into a complex matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.Σ-Tuple{Field, Any}" href="#CMBLensing.Σ-Tuple{Field, Any}"><code>CMBLensing.Σ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">Σ(ϕ::Field,  ds; [conjgrad_kwargs])
Σ(Lϕ,        ds; [conjgrad_kwargs])</code></pre><p>An operator for the data covariance, <code>Cn + M*B*L*Cf*L&#39;*B&#39;*M&#39;</code>, which can applied and inverted. <code>conjgrad_kwargs</code> are passed to the underlying call to <code>conjugate_gradient</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.logdet-Tuple{FieldOp{T} where T, Any}" href="#LinearAlgebra.logdet-Tuple{FieldOp{T} where T, Any}"><code>LinearAlgebra.logdet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre class="language-julia"><code class="language-julia">logdet(L::FieldOp, θ)</code></pre><p>If <code>L</code> depends on <code>θ</code>, evaluates <code>logdet(L(θ))</code> offset by its fiducial value at <code>L()</code>. Otherwise, returns 0.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.BatchedReal" href="#CMBLensing.BatchedReal"><code>CMBLensing.BatchedReal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre class="language-julia"><code class="language-julia">BatchedReal(::Vector{&lt;:Real}) &lt;: Real</code></pre><p>Holds a vector of real numbers and broadcasts algebraic operations over them, as well as broadcasting along the batch dimension of <code>Field</code>s, but is itself a <code>Real</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.@!-Tuple{Any}" href="#CMBLensing.@!-Tuple{Any}"><code>CMBLensing.@!</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Rewrites <code>@! x = f(args...)</code> to <code>x = f!(x,args...)</code></p><p>Special cases for <code>*</code> and <code>\</code> forward to <code>mul!</code> and <code>ldiv!</code>, respectively.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.@auto_adjoint-Tuple{Any}" href="#CMBLensing.@auto_adjoint-Tuple{Any}"><code>CMBLensing.@auto_adjoint</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre class="language-julia"><code class="language-julia">@auto_adjoint foo(args...; kwargs...) = body</code></pre><p>is equivalent to </p><pre class="language-none"><code class="language-none">_foo(args...; kwargs...) = body
foo(args...; kwargs...) = _foo(args...; kwargs...)
@adjoint foo(args...; kwargs...) = Zygote.pullback(_foo, args...; kwargs...)</code></pre><p>That is, it defines the function as well as a Zygote adjoint which takes a gradient explicitly through the body of the function, rather than relying on rules which may be defined for <code>foo</code>. Mainly useful in the case that <code>foo</code> is a common function with existing rules, but which you do <em>not</em> want to be used.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.@dict-Tuple" href="#CMBLensing.@dict-Tuple"><code>CMBLensing.@dict</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Pack some variables in a dictionary </p><pre class="language-julia"><code class="language-julia">&gt; x = 3
&gt; y = 4
&gt; @dict x y z=&gt;5
Dict(:x=&gt;3,:y=&gt;4,:z=&gt;5)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.@ondemand-Tuple{Any}" href="#CMBLensing.@ondemand-Tuple{Any}"><code>CMBLensing.@ondemand</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre class="language-julia"><code class="language-julia">@ondemand(Package.function)(args...; kwargs...)
@ondemand(Package.Submodule.function)(args...; kwargs...)</code></pre><p>Just like calling <code>Package.function</code> or <code>Package.Submodule.function</code>, but <code>Package</code> will be loaded on-demand if it is not already loaded. The call is no longer inferrable.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CMBLensing.@subst-Tuple{Any}" href="#CMBLensing.@subst-Tuple{Any}"><code>CMBLensing.@subst</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre class="language-julia"><code class="language-julia">@subst sum(x*$(y+1) for x=1:2)</code></pre><p>becomes</p><pre class="language-none"><code class="language-none">let tmp=(y+1)
    sum(x*tmp for x=1:2)
end</code></pre><p>to aid in writing clear/succinct code that doesn&#39;t recompute things unnecessarily.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../06_gpu/">« GPU</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 17 September 2021 01:24">Friday 17 September 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
