<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The Lensing Posterior Â· CMBLensing.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/cmblensing.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CMBLensing.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">CMBLensing.jl</a></li><li><a class="tocitem" href="../01_lense_a_map/">Lensing a flat-sky map</a></li><li class="is-active"><a class="tocitem" href>The Lensing Posterior</a><ul class="internal"><li><a class="tocitem" href="#Posterior-basics-1"><span>Posterior basics</span></a></li><li><a class="tocitem" href="#Wiener-filtering-1"><span>Wiener filtering</span></a></li><li><a class="tocitem" href="#Posterior-gradients-1"><span>Posterior gradients</span></a></li></ul></li><li><a class="tocitem" href="../03_joint_MAP_example/">MAP estimation</a></li><li><a class="tocitem" href="../04_from_python/">Calling from Python</a></li><li><a class="tocitem" href="../05_field_basics/">Field Basics</a></li><li><a class="tocitem" href="../06_gpu/">GPU</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"></nav><div class="docs-right"><a class="docs-right" href="https://mybinder.org/v2/gh/marius311/CMBLensing.jl/gh-pages?urlpath=lab/tree/02_posterior.ipynb"><img src="https://mybinder.org/badge_logo.svg"/></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="The-Lensing-Posterior-1"><a class="docs-heading-anchor" href="#The-Lensing-Posterior-1">The Lensing Posterior</a><a class="docs-heading-anchor-permalink" href="#The-Lensing-Posterior-1" title="Permalink"></a></h1><p>At its heart, CMBLensing.jl is centered around the &quot;CMB lensing posterior&quot;. We work with both the &quot;<strong>joint posterior</strong>&quot;, which is joint over all variables,</p><div>\[ \mathcal{P}(f,\phi,\theta\,|\,d), \]</div><p>or the &quot;<strong>marginal posterior</strong>&quot;, </p><div>\[ \mathcal{P}(\phi,\theta\,|\,d) \equiv \int \! \mathcal{D}f \; \mathcal{P}(f,\phi,\theta\,|\,d), \]</div><p>which is simply the joint posterior analytically marginalized over <span>$f$</span>. Here,</p><ul><li><span>$f$</span> are the CMB fields (T/Q/U),</li><li><span>$\phi$</span> is the lensing potential,</li><li><span>$\theta$</span> are any cosmological parameters,</li><li><span>$d$</span> is the data.</li></ul><p>The default data model which is assumed, which is generally flexible enough to handle real experiments (but can be customized), is:</p><div>\[ d =  \mathbb{A} \, \mathbb{L}(\phi) \, f + n, \]</div><p>where</p><div>\[ \mathbb{A} = \mathbb{M} \, \mathbb{B} \]</div><p>and </p><ul><li><span>$\mathbb{L}(\phi)$</span> is the lensing operation</li><li><span>$\mathbb{B}$</span> is an instrumental transfer function or &quot;beam&quot;</li><li><span>$\mathbb{M}$</span> is a user-chosen mask</li><li><span>$n$</span> is the instrumental noise. </li></ul><p>Given this model, the joint posterior (up to an unimportant normalization constant) is:</p><div>\[ 
-2\ln\mathcal{P}(f,\phi,\theta\,|\,d) = \frac{\big(d - \mathbb{A} \, \mathbb{L}(\phi) \, f\big)^2}{\mathbb{C}_n}
+ \frac{f^2}{\mathbb{C}_f(\theta)} + \frac{\phi^2}{C_\phi(\theta)} + \log\det \mathbb{C}_f(\theta) + \log\det C_\phi(\theta),
\]</div><p>and the marginal posterior is:</p><div>\[ 
-2\ln\mathcal{P}(\phi,\theta\,|\,d) = \frac{d^2}{\mathbb{\Sigma}_d(\phi,\theta)} + \frac{\phi^2}{C_\phi(\theta)} + \log\det \mathbb{\Sigma}_d(\phi,\theta) + \log\det C_\phi(\theta),
\]</div><p>where</p><div>\[
\Sigma_d = \mathbb{A} \, \mathbb{L}(\phi) \, \mathbb{C}_f(\theta) \, \mathbb{L}(\phi)^\dagger \mathbb{A}^\dagger + \mathbb{C}_n
\]</div><p>and</p><ul><li><span>$\mathbb{C}_n$</span> is the noise covariance</li><li><span>$\mathbb{C}_f$</span> is the CMB covariance (i.e. the CMB T, E, and B <span>$C_\ell$</span>&#39;s)</li><li><span>$\mathbb{C}_\phi$</span> is the lensing potential covariance (i.e. <span>$C_\ell^{\phi\phi}$</span>)</li></ul><p>and we have used the slighly sloppy notation <span>$x^2/\mathbb{C}$</span> to mean <span>$x^\dagger \mathbb{C}^{-1} x$</span>.</p><h2 id="Posterior-basics-1"><a class="docs-heading-anchor" href="#Posterior-basics-1">Posterior basics</a><a class="docs-heading-anchor-permalink" href="#Posterior-basics-1" title="Permalink"></a></h2><pre class="language-julia"><code class="language-julia">using CMBLensing, PyPlot</code></pre><p>CMBLensing uses the function <code>logpdf</code> to compute the log of the joint posterior probability. </p><p>To evaluate this posterior, we need the arguments of the probability distribution, <span>$f$</span>, <span>$\phi$</span>, and <span>$\theta$</span>. We also need the data <span>$d$</span> and host of other operators and covariances which enter the expressions above, which CMBLensing stores in a <code>DataSet</code> object.</p><p>First lets load up some simulated data. The function <code>load_sim</code> handles constructing a <code>DataSet</code> and is the recommended way to create the various fields and covariances needed. In this case, let&#39;s use 1<span>$\mu$</span>K-arcmin noise and a border mask:</p><pre class="language-julia"><code class="language-julia">@unpack f, fÌƒ, Ï•, ds = load_sim(
    Î¸pix      = 2,
    Nside     = 256,
    T         = Float64,
    pol       = :P,
    Î¼KarcminT = 1,
    L         = LenseFlow{RK4Solver{10}},
    seed      = 0,
    pixel_mask_kwargs = (edge_padding_deg=1, apodization_deg=0, num_ptsrcs=0),
    bandpass_mask     = LowPass(5000)
);</code></pre><p>The <code>DataSet</code> object, by convention called <code>ds</code>, stores all the aforementioned quantities:</p><pre class="language-julia"><code class="language-julia">fieldnames(typeof(ds))</code></pre><pre class="language-output"><code class="language-output">(:d, :Cf, :Cn, :CnÌ‚, :M, :MÌ‚, :B, :BÌ‚, :CÏ•, :CfÌƒ, :D, :G, :L, :NÏ•)</code></pre><p>For example, the data is:</p><pre class="language-julia"><code class="language-julia">plot(ds.d);</code></pre><p><img src="../02_posterior_files/02_posterior_11_0.png" alt="png"/></p><pre class="language-output"><code class="language-output">â”Œ Warning: `vendor()` is deprecated, use `BLAS.get_config()` and inspect the output instead
â”‚   caller = npyinitialize() at numpy.jl:67
â”” @ PyCall /home/cosmo/.julia/packages/PyCall/L0fLP/src/numpy.jl:67</code></pre><p>Or the diagonal of the <span>$\mathbb{C}_f$</span> operator:</p><pre class="language-julia"><code class="language-julia">plot(diag(ds.Cf), which=[:El :Bl])</code></pre><p><img src="../02_posterior_files/02_posterior_13_0.png" alt="png"/></p><p>We can now evaluate the posterior, for example at the true <span>$f$</span> and <span>$\phi$</span>:</p><pre class="language-julia"><code class="language-julia">logpdf(ds; f, Ï•)</code></pre><pre class="language-output"><code class="language-output">1.6744637875507844e6</code></pre><p>There is a particular change-of-variables called the &quot;mixed parameterization&quot; (see <a href="https://arxiv.org/abs/2002.00965">our paper</a> for details) which helps make the the posterior a little less correlated and more amenable to sampling and maximization. We can apply the change-of-variables to some point in parameter space as:</p><pre class="language-julia"><code class="language-julia">fÂ°, Ï•Â° = mix(ds; f, Ï•);</code></pre><p>Then we can evaluate the posterior in the mixed parameterization:</p><pre class="language-julia"><code class="language-julia">logpdf(Mixed(ds); fÂ°, Ï•Â°)</code></pre><pre class="language-output"><code class="language-output">1.6744675927839563e6</code></pre><p>Note that this is the same value as above since we are just evaluating the same point in parameter space, just parameterized in terms of different variables.</p><p>Above, we didn&#39;t specify any cosmological parameters, <span>$\theta$</span>. Because of that, they were fixed at their fiducial values (i.e. the fiducial values which generated the simulated data in the call to <code>load_sim</code> earlier). Current only two parameters can be varied, <span>$r$</span> (tensor-to-scalar ratio), and <span>$A_\phi$</span> (the amplitude of <span>$C_\ell^{\phi \phi}$</span>). They can be specified as follows, with non-specified parameters left at their fiducial:</p><pre class="language-julia"><code class="language-julia">logpdf(ds; f, Ï•, Î¸=(AÏ•=1.1,))</code></pre><pre class="language-output"><code class="language-output">1.6743231420008384e6</code></pre><p>You can see the slight change compared to what we got above. We can even compute a whole slice through the posterior along <span>$A_\phi$</span>:</p><pre class="language-julia"><code class="language-julia">AÏ•s = range(0.5,1.5,length=50)
plot(AÏ•s, [logpdf(ds; f, Ï•, Î¸=(;AÏ•)) for AÏ• in AÏ•s])
xlabel(raw&quot;$A_\phi$&quot;)
ylabel(raw&quot;$\log\mathcal{P}(f_{\rm true}, \phi_{\rm true}, A_\phi\,|\,d)$&quot;);</code></pre><p><img src="../02_posterior_files/02_posterior_24_0.png" alt="png"/></p><h2 id="Wiener-filtering-1"><a class="docs-heading-anchor" href="#Wiener-filtering-1">Wiener filtering</a><a class="docs-heading-anchor-permalink" href="#Wiener-filtering-1" title="Permalink"></a></h2><p>If we fix <span>$\phi$</span> and <span>$\theta$</span> then maximize the joint posterior, <span>$\mathcal{P}(f,\phi,\theta\,|\,d)$</span>, over <span>$f$</span>, we get</p><div>\[
\hat f_{\rm wf} = \big[ \mathbb{C}_f(\theta)^{-1} + \mathbb{L}(\phi)^\dagger \mathbb{A}^\dagger\mathbb{C}_n^{-1}\mathbb{A} \, \mathbb{L}(\phi) \big]^{-1} \mathbb{L}(\phi)^\dagger \mathbb{A}^\dagger\mathbb{C}_n^{-1}d
\]</div><p>This is simply the Wiener filter of the data given a signal covariance which includes correlations induced by <span>$\phi$</span>, and we can compute it by inverting the operator in brackets above with e.g. conjugate gradient. </p><p>In CMBLensing.jl, the <code>argmaxf_logpdf</code> function performs this task. Its arguments are similar to <code>logpdf</code>,</p><pre class="language-julia"><code class="language-julia">f_wf, = argmaxf_logpdf(ds, (;Ï•); conjgrad_kwargs=(tol=1e-1,progress=true));</code></pre><pre class="language-output"><code class="language-output">[32mConjugate Gradient: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| Time: 0:00:29[39m</code></pre><p>Wiener filtering effectively delenses the data by a given <span>$\phi$</span>. Here we are Wiener filtering at the true <span>$\phi$</span>, so this is perfect delensing. Note below the large amount of B mode power in the data, as well as the aliasing near the border mask, and how this is removed in the Wiener filtered B, which visually is tracing the true B map up to the level of the noise.</p><pre class="language-julia"><code class="language-julia">plot([ds.d, f_wf, f], title=[&quot;data &quot;, &quot;Wiener filtered &quot;, &quot;true &quot;] .* [&quot;E&quot; &quot;B&quot;]);</code></pre><p><img src="../02_posterior_files/02_posterior_30_0.png" alt="png"/></p><h2 id="Posterior-gradients-1"><a class="docs-heading-anchor" href="#Posterior-gradients-1">Posterior gradients</a><a class="docs-heading-anchor-permalink" href="#Posterior-gradients-1" title="Permalink"></a></h2><p>Fundamental to maximization and sampling algorithms in high dimensions are gradients of the posterior. CMBLensing.jl uses the interface provided by the automatic differentiation library <a href="https://github.com/FluxML/Zygote.jl/">Zygote</a> to compute these gradients.</p><pre class="language-julia"><code class="language-julia">using Zygote</code></pre><p>Zygote provides the <code>gradient</code> function, which takes a function for which to evaluate the gradient as the first argument, and the value at which to evaluate the gradient as the second argument. For example:</p><pre class="language-julia"><code class="language-julia">gradient(x-&gt;3x^2+2x, 1)</code></pre><pre class="language-output"><code class="language-output">(8.0,)</code></pre><p>Gradients of the CMB lensing posterior work in exactly the same way. For example, to take the gradient with respect to <span>$\phi$</span> in the mixed parametrization, where we fix <span>$f$</span> to the Wiener filter computed above and evaluate the gradient at <span>$\phi=0$</span>, we can do:</p><pre class="language-julia"><code class="language-julia">gÏ• = gradient(Ï•Â° -&gt; logpdf(Mixed(ds); fÂ°=f_wf, Ï•Â°), 0Ï•)[1];</code></pre><p>Here&#39;s what this gradient looks like multiplied by <span>$\mathbb{C}_\phi$</span>. This is actually the first gradient step in the iterative joint maximum a posteriori estimation. You can see below this very broadly matches the truth:</p><pre class="language-julia"><code class="language-julia">plot([ds.CÏ•*gÏ• Ï•], title=[&quot;gradient step&quot; &quot;true Ï•&quot;])</code></pre><p><img src="../02_posterior_files/02_posterior_39_0.png" alt="png"/></p><p>You are free to manipulate the fields inside of the function whose gradient is being taken, and Zygote will automatically propagate the chain rule for you:</p><pre class="language-julia"><code class="language-julia">gradient(Ï• -&gt; -2logpdf(ds; f=f_wf, Ï•=3Ï•), 0Ï•)[1] â‰ˆ -6 * gradient(Ï• -&gt; logpdf(ds; f=f_wf, Ï•), 0Ï•)[1]</code></pre><pre class="language-output"><code class="language-output">true</code></pre><p>Automatic differentiation with respect to any and all arguments of <code>logpdf</code> works, including the cosmological parameters:</p><pre class="language-julia"><code class="language-julia">gradient(AÏ• -&gt; logpdf(ds; f, Ï•, Î¸=(;AÏ•)), 1)</code></pre><pre class="language-output"><code class="language-output">(39.23843471356467,)</code></pre><p>Currently Zygote is working with many (but not all) operations that you can do to fields. If you run into things which Zygote is not able to differentiate successfully (generally you&#39;ll get some error), please feel free to file an <a href="https://github.com/marius311/CMBLensing.jl/issues">Issue</a> with CMBLensing.jl.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../01_lense_a_map/">Â« Lensing a flat-sky map</a><a class="docs-footer-nextpage" href="../03_joint_MAP_example/">MAP estimation Â»</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 23 December 2021 19:03">Thursday 23 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
