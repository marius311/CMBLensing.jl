var documenterSearchIndex = {"docs":
[{"location":"01_lense_a_map/#Lensing-a-flat-sky-map","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"","category":"section"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"using CMBLensing, PythonPlot","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"\u001b[32m\u001b[1m    CondaPkg \u001b[22m\u001b[39m\u001b[0mFound dependencies: /home/cosmo/.julia/packages/PythonCall/wXfah/CondaPkg.toml\n\u001b[32m\u001b[1m    CondaPkg \u001b[22m\u001b[39m\u001b[0mFound dependencies: /home/cosmo/.julia/packages/PythonPlot/KcWMF/CondaPkg.toml\n\u001b[32m\u001b[1m    CondaPkg \u001b[22m\u001b[39m\u001b[0mFound dependencies: /home/cosmo/CMBLensing/CondaPkg.toml\n\u001b[32m\u001b[1m    CondaPkg \u001b[22m\u001b[39m\u001b[0mDependencies already up to date","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"First we load a simulated unlensed field, f, and lensing potential, phi,","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"(;ds, f, ϕ) = load_sim(\n    θpix  = 2,       # size of the pixels in arcmin\n    Nside = 256,     # number of pixels per side in the map\n    T     = Float32, # Float32 or Float64 (former is ~twice as fast)\n    pol   = :I,      # :I for Intensity, :P for polarization, or :IP for both\n);","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"We can lense the map with LenseFlow,","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"f̃ = LenseFlow(ϕ) * f;","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"And flip between lensed and unlensed maps,","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"animate([f,f̃], fps=1)","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"<video width=\"560\" height=\"400\" controls autoplay loop>\n  <source type=\"video/mp4\" src=\"data:video/mp4;base64,AAAAHGZ0eXBNNFYgAAACAGlzb21pc28yYXZjMQAAAAhmcmVlAADDdG1kYXQAAAKtBgX//6ncRem9\n5tlIt5Ys2CDZI+7veDI2NCAtIGNvcmUgMTU1IHIyOTE3IDBhODRkOTggLSBILjI2NC9NUEVHLTQg\nQVZDIGNvZGVjIC0gQ29weWxlZnQgMjAwMy0yMDE4IC0gaHR0cDovL3d3dy52aWRlb2xhbi5vcmcv\neDI2NC5odG1sIC0gb3B0aW9uczogY2FiYWM9MSByZWY9MyBkZWJsb2NrPTE6MDowIGFuYWx5c2U9\nMHgzOjB4MTEzIG1lPWhleCBzdWJtZT03IHBzeT0xIHBzeV9yZD0xLjAwOjAuMDAgbWl4ZWRfcmVm\nPTEgbWVfcmFuZ2U9MTYgY2hyb21hX21lPTEgdHJlbGxpcz0xIDh4OGRjdD0xIGNxbT0wIGRlYWR6\nb25lPTIxLDExIGZhc3RfcHNraXA9MSBjaHJvbWFfcXBfb2Zmc2V0PS0yIHRocmVhZHM9NiBsb29r\nYWhlYWRfdGhyZWFkcz0xIHNsaWNlZF90aHJlYWRzPTAgbnI9MCBkZWNpbWF0ZT0xIGludGVybGFj\nZWQ9MCBibHVyYXlfY29tcGF0PTAgY29uc3RyYWluZWRfaW50cmE9MCBiZnJhbWVzPTMgYl9weXJh\nbWlkPTIgYl9hZGFwdD0xIGJfYmlhcz0wIGRpcmVjdD0xIHdlaWdodGI9MSBvcGVuX2dvcD0wIHdl\naWdodHA9MiBrZXlpbnQ9MjUwIGtleWludF9taW49MSBzY2VuZWN1dD00MCBpbnRyYV9yZWZyZXNo\nPTAgcmNfbG9va2FoZWFkPTQwIHJjPWNyZiBtYnRyZWU9MSBjcmY9MjMuMCBxY29tcD0wLjYwIHFw\nbWluPTAgcXBtYXg9NjkgcXBzdGVwPTQgaXBfcmF0aW89MS40MCBhcT0xOjEuMDAAgAAApI5liIQA\nFv/+99M/zLLr9zm146j3op4mX0N1JQGblsTtOoAAAAMAAAMAC0a6h54v/Qh2f/CIx8AA4okh7EEn\nlkFs5VjlmuuR0hUiIo1oaoTqxptJDglA2dVrFJ0IPlFcV7bhBG8RSXm0Z7QgXzoZO/l+sCg/ZKWx\nKi+tSrVAeryT7BUWC+sWJkWB+FKgzBR0IXDQoq83UpjVLCkxiqg9vfLkw/7/xRusrNZtuiFz1acR\n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\n\">\n  Your browser does not support the video tag.\n</video>","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"The difference between lensed and unlensed,","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"plot(f-f̃);","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"(Image: png)","category":"page"},{"location":"01_lense_a_map/#Loading-your-own-data","page":"Lensing a flat-sky map","title":"Loading your own data","text":"","category":"section"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"CMBLensing flat-sky Field objects like f or ϕ  are just thin wrappers around arrays. You can get the underlying data arrays for I(mathbfx), Q(mathbfx), and U(mathbfx) with f[:Ix], f[:Qx], and f[:Ux] respectively, or the Fourier coefficients, I(mathbfl), Q(mathbfl), and U(mathbfl) with f[:Il], f[:Ql], and f[:Ul],","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"mapdata = f[:Ix]","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"256×256 view(::Matrix{Float32}, :, :) with eltype Float32:\n -145.974  -134.078  -120.918   -104.631   …  -198.186   -189.465   -165.136\n -151.474  -135.045  -112.763    -82.849      -195.957   -189.838   -169.182\n -155.79   -132.561  -103.972    -71.0759     -191.606   -189.953   -174.786\n -163.767  -133.438   -97.1812   -64.4921     -181.429   -188.062   -182.345\n -170.502  -140.476  -102.696    -70.9361     -168.72    -185.25    -186.682\n -169.757  -138.253  -109.184    -85.781   …  -166.162   -190.397   -192.965\n -162.508  -128.104  -109.931    -98.6977     -180.037   -200.872   -195.384\n -146.524  -117.715  -108.818   -106.16       -197.524   -202.771   -182.602\n -129.488  -113.162  -112.093   -109.124      -200.593   -192.268   -161.24\n -122.481  -116.836  -118.426   -110.656      -191.381   -179.099   -148.322\n -130.762  -127.468  -128.24    -119.368   …  -188.151   -177.104   -152.178\n -150.812  -145.954  -144.624   -137.148      -195.465   -188.456   -170.024\n -177.295  -169.391  -162.297   -152.499      -207.631   -206.448   -192.582\n    ⋮                                      ⋱                           ⋮\n -147.817  -162.499  -167.816   -165.661       -67.7319   -90.9288  -122.547\n -146.813  -167.485  -176.803   -173.321   …   -77.4413   -95.0936  -121.279\n -165.042  -182.129  -183.873   -174.909       -99.3494  -116.674   -141.429\n -179.04   -190.76   -189.502   -179.477      -115.868   -136.135   -159.87\n -176.421  -188.881  -194.36    -190.284      -120.681   -141.567   -162.437\n -170.162  -182.07   -192.207   -192.601      -125.044   -144.057   -158.927\n -162.916  -165.907  -172.879   -172.803   …  -144.07    -155.13    -159.96\n -154.837  -145.103  -148.443   -148.525      -174.634   -175.237   -166.964\n -155.639  -143.003  -147.58    -145.384      -201.79    -194.739   -176.193\n -161.363  -157.656  -164.607   -157.939      -213.942   -202.75    -180.083\n -157.673  -158.602  -163.825   -157.693      -210.279   -198.622   -173.913\n -147.652  -143.465  -141.517   -135.26    …  -202.147   -192.109   -166.505","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"If you have your own map data in an array you'd like to load into a CMBLensing Field object, you can construct it as follows:","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"FlatMap(mapdata, θpix=3)","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"65536-element 256×256-pixel 3.0′-resolution LambertMap{SubArray{Float32, 2, Matrix{Float32}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, true}}:\n -145.97389\n -151.4739\n -155.79005\n -163.76654\n -170.50171\n -169.75746\n -162.50768\n -146.52411\n -129.48804\n -122.481\n -130.76152\n -150.81198\n -177.29526\n    ⋮\n -122.54673\n -121.27854\n -141.42937\n -159.87007\n -162.43677\n -158.92677\n -159.95978\n -166.96414\n -176.19281\n -180.08272\n -173.91293\n -166.50537","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"For more info on Field objects, see Field Basics.","category":"page"},{"location":"01_lense_a_map/#Inverse-lensing","page":"Lensing a flat-sky map","title":"Inverse lensing","text":"","category":"section"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"You can inverse lense a map with the \\ operator (which does A \\ b ≡ inv(A) * b):","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"LenseFlow(ϕ) \\ f;","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"Note that this is true inverse lensing, rather than lensing by the negative deflection (which is often called \"anti-lensing\"). This means that lensing then inverse lensing a map should get us back the original map. Lets check that this is the case:","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"Ns = [7 10 20]\nplot([f - (LenseFlow(ϕ,N) \\ (LenseFlow(ϕ,N) * f)) for N in Ns],\n    title=[\"ODE steps = $N\" for N in Ns]);","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"(Image: png)","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"A cool feature of LenseFlow is that inverse lensing is trivially done by running the LenseFlow ODE in reverse. Note that as we crank up the number of ODE steps above, we recover the original map to higher and higher precision.","category":"page"},{"location":"01_lense_a_map/#Other-lensing-algorithms","page":"Lensing a flat-sky map","title":"Other lensing algorithms","text":"","category":"section"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"We can also lense via:","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"PowerLens: the standard Taylor series expansion to any order:","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":" f(x+nabla x) approx f(x) + (nabla f)(nabla phi) + frac12 (nabla nabla f) (nabla phi)^2 +  ","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"TayLens (Næss&Louis 2013): like PowerLens, but first a nearest-pixel permute step, then a Taylor expansion around the now-smaller residual displacement","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"plot([(PowerLens(ϕ,2)*f - f̃) (Taylens(ϕ,2)*f - f̃)], \n    title=[\"PowerLens - LenseFlow\" \"TayLens - LenseFlow\"]);","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"(Image: png)","category":"page"},{"location":"01_lense_a_map/#Benchmarking","page":"Lensing a flat-sky map","title":"Benchmarking","text":"","category":"section"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"LenseFlow is highly optimized code since it appears on the inner-most loop of our analysis algorithms. To benchmark LenseFlow, note that there is first a precomputation step, which caches some data in preparation for applying it to a field of a given type. This was done automatically when evaluating LenseFlow(ϕ) * f but we can benchmark it separately since in many cases this only needs to be done once for a given phi, e.g. when Wiener filtering at fixed phi,","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"using BenchmarkTools","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"@benchmark precompute!!(LenseFlow(ϕ),f)","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"BenchmarkTools.Trial: 492 samples with 1 evaluation.\n Range \u001b[90m(\u001b[39m\u001b[36m\u001b[1mmin\u001b[22m\u001b[39m … \u001b[35mmax\u001b[39m\u001b[90m):  \u001b[39m\u001b[36m\u001b[1m 7.562 ms\u001b[22m\u001b[39m … \u001b[35m21.851 ms\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmin … max\u001b[90m): \u001b[39m 0.00% … 13.12%\n Time  \u001b[90m(\u001b[39m\u001b[34m\u001b[1mmedian\u001b[22m\u001b[39m\u001b[90m):     \u001b[39m\u001b[34m\u001b[1m10.605 ms              \u001b[22m\u001b[39m\u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmedian\u001b[90m):    \u001b[39m26.57%\n Time  \u001b[90m(\u001b[39m\u001b[32m\u001b[1mmean\u001b[22m\u001b[39m ± \u001b[32mσ\u001b[39m\u001b[90m):   \u001b[39m\u001b[32m\u001b[1m10.154 ms\u001b[22m\u001b[39m ± \u001b[32m 1.593 ms\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmean ± σ\u001b[90m):  \u001b[39m20.99% ± 11.49%\n\n  \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[32m \u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m▄\u001b[39m█\u001b[34m▇\u001b[39m\u001b[39m▂\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \n  \u001b[39m▅\u001b[39m█\u001b[39m█\u001b[39m▅\u001b[39m▂\u001b[39m▁\u001b[39m▂\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▂\u001b[39m▃\u001b[39m▄\u001b[39m▃\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▂\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[32m▁\u001b[39m\u001b[39m▂\u001b[39m▃\u001b[39m▆\u001b[39m█\u001b[39m█\u001b[34m█\u001b[39m\u001b[39m█\u001b[39m▆\u001b[39m▃\u001b[39m▂\u001b[39m▂\u001b[39m▂\u001b[39m▄\u001b[39m▅\u001b[39m▇\u001b[39m▅\u001b[39m▃\u001b[39m▂\u001b[39m▁\u001b[39m▂\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▂\u001b[39m \u001b[39m▃\n  7.56 ms\u001b[90m         Histogram: frequency by time\u001b[39m        12.5 ms \u001b[0m\u001b[1m<\u001b[22m\n\n Memory estimate\u001b[90m: \u001b[39m\u001b[33m62.99 MiB\u001b[39m, allocs estimate\u001b[90m: \u001b[39m\u001b[33m804\u001b[39m.","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"Once cached, it's faster and less memory intensive to repeatedly apply the operator:","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"@benchmark Lϕ * f setup=(Lϕ=precompute!!(LenseFlow(ϕ),f))","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"BenchmarkTools.Trial: 179 samples with 1 evaluation.\n Range \u001b[90m(\u001b[39m\u001b[36m\u001b[1mmin\u001b[22m\u001b[39m … \u001b[35mmax\u001b[39m\u001b[90m):  \u001b[39m\u001b[36m\u001b[1m15.763 ms\u001b[22m\u001b[39m … \u001b[35m30.315 ms\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmin … max\u001b[90m): \u001b[39m0.00% … 10.01%\n Time  \u001b[90m(\u001b[39m\u001b[34m\u001b[1mmedian\u001b[22m\u001b[39m\u001b[90m):     \u001b[39m\u001b[34m\u001b[1m16.241 ms              \u001b[22m\u001b[39m\u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmedian\u001b[90m):    \u001b[39m0.00%\n Time  \u001b[90m(\u001b[39m\u001b[32m\u001b[1mmean\u001b[22m\u001b[39m ± \u001b[32mσ\u001b[39m\u001b[90m):   \u001b[39m\u001b[32m\u001b[1m17.886 ms\u001b[22m\u001b[39m ± \u001b[32m 2.931 ms\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmean ± σ\u001b[90m):  \u001b[39m3.21% ±  5.71%\n\n  \u001b[39m▄\u001b[39m█\u001b[39m▇\u001b[34m▃\u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[32m \u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m▃\u001b[39m▁\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m▁\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \n  \u001b[39m█\u001b[39m█\u001b[39m█\u001b[34m█\u001b[39m\u001b[39m▁\u001b[39m█\u001b[39m▄\u001b[39m▁\u001b[39m▄\u001b[39m▁\u001b[39m▆\u001b[39m▁\u001b[32m▄\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m▄\u001b[39m▁\u001b[39m█\u001b[39m█\u001b[39m█\u001b[39m▇\u001b[39m▄\u001b[39m▄\u001b[39m▄\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▄\u001b[39m▄\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▄\u001b[39m▄\u001b[39m▄\u001b[39m▁\u001b[39m▁\u001b[39m▆\u001b[39m▁\u001b[39m▄\u001b[39m▇\u001b[39m█\u001b[39m█\u001b[39m▆\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▄\u001b[39m▄\u001b[39m▁\u001b[39m▆\u001b[39m \u001b[39m▄\n  15.8 ms\u001b[90m      \u001b[39m\u001b[90mHistogram: \u001b[39m\u001b[90m\u001b[1mlog(\u001b[22m\u001b[39m\u001b[90mfrequency\u001b[39m\u001b[90m\u001b[1m)\u001b[22m\u001b[39m\u001b[90m by time\u001b[39m      26.5 ms \u001b[0m\u001b[1m<\u001b[22m\n\n Memory estimate\u001b[90m: \u001b[39m\u001b[33m16.13 MiB\u001b[39m, allocs estimate\u001b[90m: \u001b[39m\u001b[33m441\u001b[39m.","category":"page"},{"location":"01_lense_a_map/","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"Note that this documentation is generated on limited-performance cloud servers. Actual benchmarks are likely much faster locally or on a cluster, and yet (much) faster on GPU.","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#Simulation","page":"API","title":"Simulation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"load_sim\nsimulate","category":"page"},{"location":"api/#CMBLensing.load_sim","page":"API","title":"CMBLensing.load_sim","text":"load_sim(;kwargs...)\n\nThe starting point for many typical sessions. Creates a BaseDataSet object with some simulated data, returing the DataSet and simulated truths, which can then be passed to other maximization / sampling functions. E.g.:\n\n@unpack f,ϕ,ds = load_sim(;\n    θpix  = 2,\n    Nside = 128,\n    pol   = :P,\n    T     = Float32\n)\n\nKeyword arguments: \n\nθpix — Angular resolution, in arcmin. \nNside — Number of pixels in the map as an (Ny,Nx) tuple, or a single number for square maps. \npol — One of :I, :P, or :IP to select intensity, polarization, or both. \nT = Float32 — Precision, either Float32 or Float64.\nstorage = Array — Set to CuArray to use GPU.\nNbatch = nothing — Number of batches of data in this dataset.\nμKarcminT = 3 — Noise level in temperature in μK-arcmin.\nℓknee = 100 — 1/f noise knee.\nαknee = 3 — 1/f noise slope.\nbeamFWHM = 0 — Beam full-width-half-max in arcmin.\npixel_mask_kwargs = (;) — NamedTuple of keyword arguments to pass to make_mask to create the pixel mask.\nbandpass_mask = LowPass(3000) — Operator which performs Fourier-space masking.\nfiducial_θ = (;) — NamedTuple of keyword arguments passed to camb() for the fiducial model.\nseed = nothing — Specific seed for the simulation.\nL = LenseFlow — Lensing operator.\n\nReturns a named tuple of (;f, f̃, ϕ, n, ds, Cℓ, proj).\n\n\n\n\n\n","category":"function"},{"location":"api/#CMBLensing.simulate","page":"API","title":"CMBLensing.simulate","text":"simulate([rng], Σ)\n\nDraw a simulation from the covariance matrix Σ, i.e. draw a random vector xi such that the covariance langle xi xi^dagger rangle = Sigma. \n\nThe random number generator rng will be used and advanced in the proccess, and defaults to Random.default_rng().\n\n\n\n\n\n","category":"function"},{"location":"api/#Lensing-estimation","page":"API","title":"Lensing estimation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"MAP_joint\nMAP_marg\nsample_joint\nargmaxf_logpdf\nquadratic_estimate","category":"page"},{"location":"api/#CMBLensing.MAP_joint","page":"API","title":"CMBLensing.MAP_joint","text":"MAP_joint([θ], ds::DataSet, [Ωstart=(ϕ=0,)]; kwargs...)\n\nCompute the maximum a posteriori (i.e. \"MAP\") estimate of the joint posterior, mathcalP(fphithetad), or compute a quasi-sample. \n\nPositional arguments:\n\n[θ] — Optional θ at which to do maximization.\nds::DataSet — The DataSet which defines the posterior\n[Ωstart=(ϕ=0,)] — Optional starting point for the non-Gaussian fields to optimize over. The maximizer does a coordinate descent which alternates between updating f which the posterior is assumed to be Gaussian in, and updating the fields in Ωstart (which by default is just ϕ).\n\nKeyword arguments:\n\nnsteps — The maximum number of iterations for the maximizer.\nϕtol = nothing — If given, stop when ϕ updates reach this tolerance. ϕtol is roughly the relative per-pixel standard deviation between changes to ϕ and draws from the ϕ prior. Values in the range 10^-2-10^-4 are reasonable. \nnburnin_update_hessian = Inf — How many steps to wait before starting to do diagonal updates to the Hessian\nconjgrad_kwargs = (;) — Passed to the inner call to conjugate_gradient.\nprogress = true — Whether to show the progress bar.\nquasi_sample = false — false to compute the MAP, true to  iterate quasi-samples, or an integer to compute a fixed-seed  quasi-sample.\nhistory_keys — What quantities to include in the returned history. Can be any subset of (:f, :f°, :ϕ, :∇ϕ_logpdf, :χ², :logpdf).\n\nReturns a tuple (f, ϕ, history) where f is the best-fit (or quasi-sample) field, ϕ is the lensing potential, and history contains the history of steps during the run. \n\n\n\n\n\n","category":"function"},{"location":"api/#CMBLensing.MAP_marg","page":"API","title":"CMBLensing.MAP_marg","text":"MAP_marg(ds; kwargs...)\n\nCompute the maximum a posteriori (i.e. \"MAP\") estimate of the marginal posterior, mathcalP(phithetad).\n\n\n\n\n\n","category":"function"},{"location":"api/#CMBLensing.sample_joint","page":"API","title":"CMBLensing.sample_joint","text":"sample_joint(ds::DataSet; kwargs...)\n\nSample the joint posterior, mathcalP(fphithetad). \n\nKeyword arguments: \n\nnsamps_per_chain — The number of samples per chain.\nnchains = 1 — Number of chains in parallel.\nnsavemaps = 1 — Number of steps in between saving maps into chain.\nnburnin_always_accept = 0 — Number of steps at the beginning of the chain to always accept HMC steps regardless of integration error.\nnburnin_fixθ = 0 — Number of steps at the beginning of the chain before starting to sample θ.\nNϕ = :qe — Noise to use in the initial approximation to the Hessian. Can give :qe to use the quadratic estimate noise.\nchains = nothing — nothing to start a new chain; the return value from a previous call to sample_joint to resume those chains; :resume to resume chains from a file given by filename\nθrange — Range and density to grid sample parameters as a NamedTuple, e.g. (Aϕ=range(0.7,1.3,length=20),). \nθstart — Starting values of parameters as a NamedTuple, e.g. (Aϕ=1.2,), or nothing to randomly sample from θrange\nϕstart — Starting ϕ, either a Field object, :quasi_sample, or :best_fit\nmetadata — Does nothing, but is saved into the chain file\nnhmc = 1 — Number of HMC passes per ϕ Gibbs step.\nsymp_kwargs = fill((N=25, ϵ=0.01), nhmc) — an array of NamedTupe kwargs to pass to symplectic_integrate. E.g. [(N=50,ϵ=0.1),(N=25,ϵ=0.01)] would do 50 large steps then 25 smaller steps per each Gibbs pass. If specified, nhmc is ignored.\nwf_kwargs — Keyword arguments to pass to argmaxf_logpdf in the Wiener Filter Gibbs step.\nMAP_kwargs — Keyword arguments to pass to MAP_joint when computing the starting point.\n\n\n\n\n\n","category":"function"},{"location":"api/#CMBLensing.argmaxf_logpdf","page":"API","title":"CMBLensing.argmaxf_logpdf","text":"argmaxf_logpdf(ds::DataSet, Ω::NamedTuple, [d = ds.d]; kwargs...)\n\nMaximize the logpdf for ds over f, given all the other arguments are held fixed at Ω. E.g.: argmaxf_logpdf(ds, (; ϕ, θ=(Aϕ=1.1,)).\n\nKeyword arguments: \n\nfstart — starting guess for f for the conjugate gradient solver\nconjgrad_kwargs — Passed to the inner call to conjugate_gradient\n\n\n\n\n\n","category":"function"},{"location":"api/#CMBLensing.quadratic_estimate","page":"API","title":"CMBLensing.quadratic_estimate","text":"quadratic_estimate(ds::DataSet, which; wiener_filtered=true)\nquadratic_estimate((ds₁::DataSet, ds₂::DataSet), which; wiener_filtered=true)\n\nCompute the quadratic estimate of ϕ given data.\n\nThe ds or (ds₁,ds₂) tuple contain the DataSet object(s) which house the data and covariances used in the estimate. Note that only the Fourier-diagonal approximations for the beam, mask, and noise, i.e. B̂, M̂, and Cn̂, are accounted for. To account full operators (if they are not actually Fourier-diagonal), you should compute the impact using Monte Carlo.\n\nIf a tuple is passed in, the result will come from correlating the data from ds₁ with that from ds₂.\n\nAn optional keyword argument AL can be passed in case the QE normalization was already computed, in which case it won't be recomputed during the calculation.\n\nReturns a named tuple of (;ϕqe, AL, Nϕ) where ϕqe is the (possibly Wiener filtered, depending on wiener_filtered option) quadratic estimate, AL is the normalization (which is already applied to ϕqe, it does not need to be applied again), and Nϕ is the analytic N⁰ noise bias (Nϕ==AL if using unlensed weights, currently only Nϕ==AL is always returned, no matter the weights)\n\n\n\n\n\n","category":"function"},{"location":"api/#Lensing-operators","page":"API","title":"Lensing operators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LenseFlow\nBilinearLens\nTaylens\nPowerLens\nCMBLensing.antilensing","category":"page"},{"location":"api/#CMBLensing.LenseFlow","page":"API","title":"CMBLensing.LenseFlow","text":"LenseFlow(ϕ, [n=7])\n\nLenseFlow is the ODE-based lensing algorithm from Millea, Anderes, & Wandelt, 2019. The number of steps in the ODE solver is controlled by n. The action of the operator, as well as its adjoint, inverse, inverse-adjoint, and gradient of any of these w.r.t. ϕ can all be computed. The log-determinant of the operation is zero independent of ϕ, in the limit of n high enough.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.BilinearLens","page":"API","title":"CMBLensing.BilinearLens","text":"BilinearLens(ϕ)\n\nBilinearLens is a lensing operator that computes lensing with bilinear interpolation. The action of the operator, as well as its adjoint, inverse, inverse-adjoint, and gradient w.r.t. ϕ can all be computed. The log-determinant of the operation is non-zero and can't be computed. \n\nInternally, BilinearLens forms a sparse matrix with the interpolation weights, which can be applied and adjoint-ed extremely fast (e.g. at least an order of magnitude faster than LenseFlow). Inverse and inverse-adjoint lensing is somewhat slower since it requires an iterative solve, here performed with the preconditioned generalized minimal residual algorithm. \n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.Taylens","page":"API","title":"CMBLensing.Taylens","text":"Taylens(ϕ, order)\n\nTaylens is a lensing operator which lenses a map with a nearest-pixel permute step followed by power series expansion in the residual displacement, to any order. This is the algorithm from Næss&Louis 2013.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.PowerLens","page":"API","title":"CMBLensing.PowerLens","text":"PowerLens(ϕ, order)\n\nPowerLens is a lensing operator which lenses a map with a power series expansion in nabla phi to any order. \n\nf(x+nabla x) approx f(x) + (nabla f)(nabla phi) + frac12 (nabla nabla f) (nabla phi)^2 +  \n\nThe action of the operator and its adjoint can be computed.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.antilensing","page":"API","title":"CMBLensing.antilensing","text":"antilensing(L::PowerLens)\n\nCreate a PowerLens operator that lenses by -ϕ instead. \n\n\n\n\n\n","category":"function"},{"location":"api/#Configuration-options","page":"API","title":"Configuration options","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CMBLensing.FFTW_NUM_THREADS\nCMBLensing.FFTW_TIMELIMIT","category":"page"},{"location":"api/#CMBLensing.FFTW_NUM_THREADS","page":"API","title":"CMBLensing.FFTW_NUM_THREADS","text":"The number of threads used by FFTW for CPU FFTs (default is the environment variable FFTW_NUM_THREADS, or if that is not specified its Sys.CPU_THREADS÷2). This must be set before creating any FlatField objects.\n\n\n\n\n\n","category":"constant"},{"location":"api/#CMBLensing.FFTW_TIMELIMIT","page":"API","title":"CMBLensing.FFTW_TIMELIMIT","text":"Time-limit for FFT planning on CPU (default: 5 seconds). This must be set before creating any FlatField objects.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Other","page":"API","title":"Other","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [CMBLensing]\nOrder   = [:function, :type, :macro, :constant]\nFilter  = x -> !(x in [\n    load_sim,\n    simulate,\n    MAP_joint,\n    MAP_marg,\n    sample_joint,\n    argmaxf_logpdf,\n    quadratic_estimate,\n    LenseFlow,\n    BilinearLens,\n    Taylens,\n    PowerLens,\n    CMBLensing.antilensing,\n    CMBLensing.FFTW_NUM_THREADS,\n    CMBLensing.FFTW_TIMELIMIT,\n])","category":"page"},{"location":"api/#CMBLensing.Jperm-Tuple{Int64, Int64}","page":"API","title":"CMBLensing.Jperm","text":"Jperm(ℓ::Int, n::Int) return the column number in the J matrix U^2 where U is unitary FFT. The J matrix looks like this:\n\n|1   0| |  / 1| | / / | |0 1  |\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.LinearInterpolation-Tuple{AbstractVector, AbstractVector}","page":"API","title":"CMBLensing.LinearInterpolation","text":"itp = LinearInterpolation(xdat::AbstractVector, ydat::AbstractVector; extrapolation_bc=NaN)\nitp(x) # interpolate at x\n\nA simple 1D linear interpolation code which is fully Zygote differentiable in either xdat, ydat, or the evaluation point x.\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.QE_leg-Tuple{Diagonal, Vararg{Any}}","page":"API","title":"CMBLensing.QE_leg","text":"QE_leg(C::Diagonal, inds...)\n\nThe quadratic estimate and normalization expressions all consist of terms involving products of two \"legs\", each leg which look like:\n\nC * l[i] * l̂[j] * l̂[k] * ...\n\nwhere C is some field or diagonal covariance, l[i] is the Fourier wave-vector in direction i (for i=1:2), and l̂[i] = l[i]/‖l‖. For example, there's a leg in the EB estimator that looks like: \n\n(CE * (CẼ+Cn) \\ d[:E])) * l[i] * l̂[j] * l̂[k]\n\nThe function QE_leg computes quatities like these, e.g. the above would be given by:\n\nQE_leg((CE * (CẼ+Cn) \\ d[:E])), [i], j, k)\n\n(where note that specifying whether its the Fourier wave-vector l instead of the unit-vector l̂ is done by putting that index in brackets).\n\nAdditionally, all of these terms are symmetric in their indices, i.e. in (i,j,k) in this case. The QE_leg function is smart about this, and is memoized so that each unique set of indices is only computed once. This leads to a pretty drastic speedup for terms with many indices like those that arize in the EE and EB normalizations, and lets us write code which is both clear and fast without having to think too hard about these symmetries.\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.assign_GPU_workers-Tuple{}","page":"API","title":"CMBLensing.assign_GPU_workers","text":"assign_GPU_workers(;print_info=true, use_master=false, remove_oversubscribed_workers=false)\n\nAssign each Julia worker process a unique GPU using CUDA.device!. Works with workers which may be distributed across different hosts, and each host can have multiple GPUs.\n\nIf a unique GPU cannot be assigned, that worker is removed if remove_oversubscribed_workers is true, otherwise an error is thrown.\n\nuse_master controls whether the master process counts as having been assigned a GPU (if false, one of the workers may be assigned the same GPU as the master)\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.batch-Union{Tuple{Vararg{BaseField{B, M, T, A} where {M<:ProjLambert, T, A<:(AbstractArray{T})}}}, Tuple{B}} where B","page":"API","title":"CMBLensing.batch","text":"batch(fs::LambertField...)\nbatch(fs::Vector{<:LambertField})\n\nConcatenate one of more LambertFields along the \"batch\" dimension (dimension 4 of the underlying array). For the inverse operation, see unbatch. \n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.beamCℓs-Tuple{}","page":"API","title":"CMBLensing.beamCℓs","text":"beamCℓs(;beamFWHM, ℓmax=8000)\n\nCompute the beam power spectrum, often called W_ell. A map should be multiplied by the square root of this.\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.conjugate_gradient","page":"API","title":"CMBLensing.conjugate_gradient","text":"conjugate_gradient(\n    M, A, b, x=M\\b; \n    nsteps       = length(b), \n    tol          = sqrt(eps()), \n    progress     = false, \n    callback     = nothing, \n    history_keys = nothing, \n    history_mod  = 1\n)\n\nCompute x=A\\b (where A is positive definite) by conjugate gradient. M is the preconditioner and should be M≈A, and M\\x should be fast.\n\nThe solver will stop either after nsteps iterations or when dot(r,r)<tol (where r=A*x-b is the residual  at that step), whichever occurs first.\n\nInfo from the iterations of the solver can be returned if history_keys is specified. history_keys can be one or a tuple of:\n\n:i — current iteration number\n:x — current solution\n:r — current residual r=A*x-b\n:res — the norm of r\n:t — the time elapsed (in seconds) since the start of the algorithm\n\nhistory_mod can be used to include every N-th iteration only in history_keys. \n\n\n\n\n\n","category":"function"},{"location":"api/#CMBLensing.cpu-Tuple{Any}","page":"API","title":"CMBLensing.cpu","text":"cpu(x)\n\nRecursively move an object to CPU memory. See also gpu.\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.fftsyms-Union{Tuple{n}, Tuple{m}, Tuple{Val{m}, Val{n}}} where {m, n}","page":"API","title":"CMBLensing.fftsyms","text":"Arguments m and n refer to the sizes of an m×n matrix (call it A) that is the output of a real FFT (thus m=n÷2+1)\n\nReturns a tuple of (ireal, iimag, negks) where these are\n\nireal — m×n mask corrsponding to unique real entries of A\niimag — m×n mask corrsponding to unique imaginary entries of A\nnegks — m×n matrix of giving the index into A where the negative k-vector           is, s.t. A[i,j] = A[negks[i,j]]'\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.fieldvalues-Tuple{Any}","page":"API","title":"CMBLensing.fieldvalues","text":"Return the type's fields as a tuple\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.finite_second_derivative-Tuple{Any}","page":"API","title":"CMBLensing.finite_second_derivative","text":"finite_second_derivative(x)\n\nSecond derivative of a vector x via finite differences, including at end points.\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.get_max_lensing_step-Tuple{Any, Any}","page":"API","title":"CMBLensing.get_max_lensing_step","text":"Returns αmax such that 𝕀 + ∇∇(ϕ + α * η) has non-zero discriminant (pixel-by-pixel) for all α values in [0, αmax]. \n\nThis mean ϕ + αmax * η is the maximum step in the η direction which can be added to ϕ and still yield a lensing potential in the weak-lensing regime. This is important because it guarantees the potential can be paseed to LenseFlow, which cannot handle the strong-lensing / \"shell-crossing\" regime.\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.gmres-Tuple{Any, Any}","page":"API","title":"CMBLensing.gmres","text":"gmres(A, b; maxiter, Pl=I)\n\nSolve A \\ b with maxiter iterations of the generalized minimal residual algorithm. Pl is a left-preconditioner which should approximate inv(A). \n\nNote: the implemenation is memory inefficient and uses O(n * maxiter) memory, where n,n=size(A) (may not be a big deal for small maxiter), although is totally generic and works with CPU or GPU and dense or sparse matrices, unlike IterativeSolver's gmres.\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.gpu","page":"API","title":"CMBLensing.gpu","text":"gpu(x)\n\nRecursively move an object to GPU memory. Note that, unlike cu(x), this does not change the eltype of any underlying arrays. See also cpu.\n\n\n\n\n\n","category":"function"},{"location":"api/#CMBLensing.gradhess-Tuple{Any}","page":"API","title":"CMBLensing.gradhess","text":"gradhess(f)\n\nCompute the gradient g^i = nabla^i f, and the hessian, H_j^i = nabla_j nabla^i f.\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.grid_and_sample-Tuple{Union{Function, Type}, AbstractVector}","page":"API","title":"CMBLensing.grid_and_sample","text":"grid_and_sample(lnP::Callable; range::NamedTuple; progress=false, nsamples=1)\n\nInterpolate the log pdf lnP with support on range, and return  the integrated log pdf as well nsamples samples (drawn via inverse transform sampling)\n\nlnP should either accept a NamedTuple argument and range should be a NamedTuple mapping those same names to range objects specifying where to evaluate lnP, e.g.:\n\ngrid_and_sample(nt->-(nt.x^2+nt.y^2)/2, (x=range(-3,3,length=100),y=range(-3,3,length=100)))\n\nor lnP should accept a single scalar argument and range should be directly the range for this variable:\n\ngrid_and_sample(x->-x^2/2, range(-3,3,length=100))\n\nThe return value is (lnP, samples, Px) where lnP is an interpolated/smoothed log PDF which can be evaluated anywhere within the original range, Px are sampled points of the original PDF, and samples is a NamedTuple giving the Monte-Carlo samples of each of the parameters.\n\n(Note: only 1D sampling is currently implemented, but 2D like in the example above is planned)\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.kde-Tuple{AbstractVector}","page":"API","title":"CMBLensing.kde","text":"kde(samples::AbstractVector; [boundary=(min,max), normalize=\"integral\" or \"max\"])\nkde(samples::AbstractMatrix; [boundary=[(min1,max1),(min2,max2)], normalize=\"integral\" or \"max\", smooth_scale_2D])\n\nReturn a Kernel Density Estimate for a set of 1D or 2D samples. The return object is a function which can be evaluated anywhere to compute the PDF. If provided, boundary specifies a hard upper/lower bound for the 1 or 2 or parameters, normalize specifies whether to normalize the PDF to unit integral or unit maximum, and smooth_scale_2D specifies how much smoothing to do for the 2D case.\n\nBased on Python GetDist,  which must be installed.\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.load_camb_Cℓs-Tuple{}","page":"API","title":"CMBLensing.load_camb_Cℓs","text":"load_camb_Cℓs(;path_prefix, custom_tensor_params=nothing, \n    unlensed_scalar_postfix, unlensed_tensor_postfix, lensed_scalar_postfix, lenspotential_postfix)\n\nLoad some Cℓs from CAMB files. \n\npath_prefix specifies the prefix for the files, which are then expected to have the normal CAMB postfixes: scalCls.dat, tensCls.dat, lensedCls.dat, lenspotentialCls.dat, unless otherwise specified via the other keyword arguments. custom_tensor_params can be used to call CAMB directly for the unlensed_tensors, rather than reading them from a file (since alot of times this file doesn't get saved). The value should be a Dict/NamedTuple which will be passed to a call to camb, e.g. custom_tensor_params=(r=0,) for zero tensors. \n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.load_chains-Tuple{Any}","page":"API","title":"CMBLensing.load_chains","text":"load_chains(filename; burnin=0, burnin_chunks=0, thin=1, join=false, unbatch=true)\n\nLoad a single chain or multiple parallel chains which were written to a file by sample_joint. \n\nKeyword arguments: \n\nburnin — Remove this many samples from the start of each chain, or if negative, keep only this many samples at the end of each chain.\nburnin_chunks — Same as burnin, but in terms of chain \"chunks\" stored in the chain file, rather than in terms of samples.\nthin — If thin is an integer, thin the chain by this factor. If thin == :hasmaps, return only samples which have maps saved. If thin is a Function, filter the chain by this function (e.g. thin=haskey(:g) on Julia 1.5+)\nunbatch — If true, run unbatch on the chains if they are batched.\njoin — If true, concatenate all the chains together.\nskip_missing_chunks — Skip missing chunks in the chain instead of terminating the chain there. \n\nThe object returned by this function is a Chain or Chains object, which simply wraps an Array of Dicts or an Array of Array of Dicts, respectively (each sample is a Dict). The wrapper object has some extra indexing properties for convenience: \n\nIt can be indexed as if it were a single multidimensional object, e.g. chains[1,:,:accept] would return the :accept key of all samples in the first chain.\nLeading colons can be dropped, i.e. chains[:,:,:accept] is the same as chains[:accept]. \nIf some samples are missing a particular key, missing is returned for those samples insted of an error.\nThe recursion goes arbitrarily deep into the objects it finds. E.g., since sampled parameters are stored in a NamedTuple like (Aϕ=1.3,) in the θ key of each sample Dict, you can do chain[:θ,:Aϕ] to get all Aϕ samples as a vector. \n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.longest_run_of_trues-Tuple{Any}","page":"API","title":"CMBLensing.longest_run_of_trues","text":"longest_run_of_trues(x)\n\nThe slice corresponding to the longest run of trues in the vector x. \n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.mean_std_and_errors-Tuple{Any}","page":"API","title":"CMBLensing.mean_std_and_errors","text":"mean_std_and_errors(samples; N_bootstrap=10000)\n\nGet the mean and standard deviation of a set of correlated samples from a chain where the error on the mean and standard deviation is estimated with bootstrap resampling using the calculated \"effective sample size\" of the chain.\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.mix-Tuple{DataSet}","page":"API","title":"CMBLensing.mix","text":"mix(ds::DataSet; f, ϕ, [θ])\n\nCompute the mixed (f°, ϕ°) from the unlensed field f and lensing potential ϕ, given the definition of the mixing matrices in ds evaluated at parameters θ (or at fiducial values if no θ provided).\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.noiseCℓs-Tuple{}","page":"API","title":"CMBLensing.noiseCℓs","text":"noiseCℓs(;μKarcminT, beamFWHM=0, ℓmax=8000, ℓknee=100, αknee=3)\n\nCompute the (:TT,:EE,:BB,:TE) noise power spectra given white noise + 1/f. Polarization noise is scaled by sqrt2 relative to μKarcminT. beamFWHM is in arcmin.\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.paren_errors-Tuple{Any, Any}","page":"API","title":"CMBLensing.paren_errors","text":"paren_errors(μ, σ; N_in_paren=2)\n\nGet a string represntation of μ ± σ in \"parenthesis\" format, e.g. 1.234 ± 0.012 becomes 1.234(12).\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.pixwin-Tuple{Any, Any}","page":"API","title":"CMBLensing.pixwin","text":"pixwin(θpix, ℓ)\n\nReturns the pixel window function for square flat-sky pixels of width θpix (in arcmin) evaluated at some ℓs. This is the scaling of k-modes, the scaling of the power spectrum will be pixwin^2. \n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.proc_info-Tuple{}","page":"API","title":"CMBLensing.proc_info","text":"proc_info()\n\nReturns string showing info about available processes.\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.project-Tuple{Pair{<:HealpixField{B, M, T} where {B, M<:ProjHealpix, T}, <:CMBLensing.CartesianProj}}","page":"API","title":"CMBLensing.project","text":"project(healpix_field::HealpixField => cart_proj::CartesianProj; [method = :bilinear])\nproject(cart_field::FlatField => healpix_proj::ProjHealpix; [method=:bilinear])\n\nProject a healpix_field to a cartesian projection specified by cart_proj, or project a cart_field back up to sphere on the Healpix pixelization specified by healpix_proj. E.g. \n\n# sphere to cartesian\nhealpix_field = HealpixMap(rand(12*2048^2))\ncart_proj = ProjLambert(Ny=128, Nx=128, θpix=3, T=Float32, rotator=(0,30,0))\nf = project(healpix_field => cart_proj)\n\n# and back to sphere\nproject(f => ProjHealpix(512))\n\nThe (Ny, Nx, θpix, rotator) parameters of cart_proj control the size and location of the projected region.\n\nThe use of => is to help remember in which order the arguments are specified. \n\nFor either projection direction, if the field is a QU or IQU field, polarization angles are rotated to be aligned with the local coordinates (sometimes called \"polarization flattening\").\n\nThe projection interpolates the original map at the positions of the centers of the projected map pixels. method controls how this interpolation is done, and can be one of:\n\n:bilinear — Bilinear interpolation (default)\n:fft — FFT-based interpolation, which uses a non-uniform FFT to evaluate the discrete Fourier series of the field at arbitrary new positions. This is currently implemented only for cartesian to Healpix projection. To make this mode available, you must load the NFFT package first. For GPU fields, you must also load CuNFFT. Projection with method=:fft is both GPU compatible and automatically differentiable.\n\nA pre-computation step can be cached by first doing, \n\nprojector = CMBLensing.Projector(healpix_map.proj => cart_proj, method=:fft)\nf = project(projector, healpix_map => cart_proj) \n\nwhich makes subsequent project calls significantly faster. Note the method argument is specified in the precomputation step.\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.rfft2vec-Tuple{AbstractMatrix}","page":"API","title":"CMBLensing.rfft2vec","text":"Convert a matrix A which is the output of a real FFT to a real vector, keeping only unqiue real/imaginary entries of A\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.rfft_degeneracy_fac-Tuple{Any}","page":"API","title":"CMBLensing.rfft_degeneracy_fac","text":"rfft_degeneracy_fac(n)\n\nReturns an Array which is 2 if the complex conjugate of the corresponding entry in the half-plane real FFT appears in the full-plane FFT, and is 1 othewise. n is the length of the first dimension of the full-plane FFT. The following identity holds:\n\nsum(abs2.(fft(x)) = sum(rfft_degeneracy_fac(size(x,1)) .* abs2.(rfft(x))\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.sample_f","page":"API","title":"CMBLensing.sample_f","text":"sample_f([rng::AbstractRNG], ds::DataSet, Ω::NamedTuple, [d = ds.d]; kwargs...)\n\nDraw a posterior sample of f from the logpdf for ds, given all the other arguments are held fixed at Ω. E.g.: sample_f(ds, (; ϕ, θ=(Aϕ=1.1,)).\n\nKeyword arguments: \n\nfstart — starting guess for f for the conjugate gradient solver\nconjgrad_kwargs — Passed to the inner call to conjugate_gradient\n\n\n\n\n\n","category":"function"},{"location":"api/#CMBLensing.symplectic_integrate-Union{Tuple{T}, Tuple{AbstractVector{T}, Any, Any, Any}, Tuple{AbstractVector{T}, Vararg{Any, 4}}} where T","page":"API","title":"CMBLensing.symplectic_integrate","text":"symplectic_integrate(x₀, p₀, Λ, U, δUδx, N=50, ϵ=0.1, progress=false)\n\nDo a symplectic integration of the potential energy U (with gradient δUδx) starting from point x₀ with momentum p₀ and mass matrix Λ. The number of steps is N and the step size ϵ. \n\nReturns ΔH, xᵢ, pᵢ corresponding to change in Hamiltonian, and final position and momenta. If history_keys is specified a history of requested variables throughout each step is also returned. \n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.ud_grade-Union{Tuple{B}, Tuple{BaseField{B, M, T, A} where {M<:ProjLambert, T, A<:(AbstractArray{T})}, Any}} where B","page":"API","title":"CMBLensing.ud_grade","text":"ud_grade(f::Field, θnew, mode=:map, deconv_pixwin=true, anti_aliasing=true)\n\nUp- or down-grades field f to new resolution θnew (only in integer steps). Two modes are available specified by the mode argument: \n\n:map     — Up/downgrade by replicating/averaging pixels in map-space\n:fourier — Up/downgrade by extending/truncating the Fourier grid\n\nFor :map mode, two additional options are possible. If deconv_pixwin is true, deconvolves the pixel window function from the downgraded map so the spectrum of the new and old maps are the same. If anti_aliasing is true, filters out frequencies above Nyquist prior to down-sampling. \n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.unbatch-Tuple{CMBLensing.Chains}","page":"API","title":"CMBLensing.unbatch","text":"unbatch(chains::Chains)\n\nExpand each chain in this Chains object by unbatching it. \n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.unbatch-Tuple{CMBLensing.Chain}","page":"API","title":"CMBLensing.unbatch","text":"unbatch(chain::Chain)\n\nConvert a chain of batch-length-D fields to D chains of unbatched fields. \n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.unbatch-Union{Tuple{BaseField{B, M, T, A} where {M<:ProjLambert, T, A<:(AbstractArray{T})}}, Tuple{B}} where B","page":"API","title":"CMBLensing.unbatch","text":"unbatch(f::LambertField)\n\nReturn an Array of LambertFields corresponding to each batch index. For the inverse operation, see batch.\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.unfold-Tuple{AbstractArray{<:Any, 3}, Any}","page":"API","title":"CMBLensing.unfold","text":"Convert an M×N matrix (with M=N÷2+1) which is the output a real FFT to a full N×N one via symmetries.\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.unmix-Tuple{DataSet}","page":"API","title":"CMBLensing.unmix","text":"unmix(f°, ϕ°,    ds::DataSet)\nunmix(f°, ϕ°, θ, ds::DataSet)\n\nCompute the unmixed/unlensed (f, ϕ) from the mixed field f° and mixed lensing potential ϕ°, given the definition of the mixing matrices in ds evaluated at parameters θ (or at fiducial values if no θ provided). \n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.vec2rfft-Tuple{AbstractVector{<:Real}}","page":"API","title":"CMBLensing.vec2rfft","text":"Convert a vector produced by rfft2vec back into a complex matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.logdet-Tuple{FieldOp, Any}","page":"API","title":"LinearAlgebra.logdet","text":"logdet(L::FieldOp, θ)\n\nIf L depends on θ, evaluates logdet(L(θ)) offset by its fiducial value at L(). Otherwise, returns 0.\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.BatchedReal","page":"API","title":"CMBLensing.BatchedReal","text":"BatchedReal(::Vector{<:Real}) <: Real\n\nHolds a vector of real numbers and broadcasts algebraic operations over them, as well as broadcasting along the batch dimension of Fields, but is itself a Real. \n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.ParamDependentOp","page":"API","title":"CMBLensing.ParamDependentOp","text":"ParamDependentOp(recompute_function::Function)\n\nCreates an operator which depends on some parameters theta and can be evaluated at various values of these parameters. \n\nrecompute_function should be a function which accepts keyword arguments for theta and returns the operator. Each keyword must have a default value; the operator will act as if evaluated at these defaults unless it is explicitly evaluated at other parameters. \n\nExample:\n\nCϕ₀ = Diagonal(...) # some fixed Diagonal operator\nCϕ = ParamDependentOp((;Aϕ=1)->Aϕ*Cϕ₀) # create ParamDependentOp\n\nCϕ(Aϕ=1.1) * ϕ   # Cϕ(Aϕ=1.1) is equal to 1.1*Cϕ₀\nCϕ * ϕ           # Cϕ alone will act like Cϕ(Aϕ=1) because that was the default above\n\nNote: if you are doing parallel work, global variables referred to in the recompute_function need to be distributed to all workers. A more robust solution is to avoid globals entirely and instead ensure all variables are \"closed\" over (and hence will automatically get distributed). This will happen by default if defining the ParamDependentOp inside any function, or can be forced at the global scope by wrapping everything in a let-block, e.g.:\n\nCϕ = let Cϕ₀=Cϕ₀\n    ParamDependentOp((;Aϕ=1)->Aϕ*Cϕ₀)\nend\n\nAfter executing the code above, Cϕ is now ready to be (auto-)shipped to any workers and will work regardless of what global variables are defined on these workers. \n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.ProjEquiRect-Tuple{}","page":"API","title":"CMBLensing.ProjEquiRect","text":"ProjEquiRect(; Ny::Int, Nx::Int, θspan::Tuple, φspan::Tuple,         T=Float32, storage=Array)\nProjEquiRect(; θ::Vector, φ::Vector, θedges::Vector, φedges::Vector, T=Float32, storage=Array)\n\nConstruct an EquiRect projection object. The projection can either be specified by:\n\nThe number of pixels Ny and Nx (corresponding to the θ and φ angular directions, respectively) and the span in radians of the field in these directions, θspan and φspan. The order in which the span tuples are given is irrelevant, either order will refer to the same field. Note, the spans correspond to the field size between outer pixel edges, not from pixel centers. If one wishes to call Cℓ_to_Cov with this projection, φspan must be an integer multiple of 2π, but other functionality will be available if this is not the case. \nA manual list of pixels centers and pixel edges, θ, φ, θedges, φedges.\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.@!-Tuple{Any}","page":"API","title":"CMBLensing.@!","text":"Rewrites @! x = f(args...) to x = f!(x,args...)\n\nSpecial cases for * and \\ forward to mul! and ldiv!, respectively.\n\n\n\n\n\n","category":"macro"},{"location":"api/#CMBLensing.@auto_adjoint-Tuple{Any}","page":"API","title":"CMBLensing.@auto_adjoint","text":"@auto_adjoint foo(args...; kwargs...) = body\n\nis equivalent to \n\n_foo(args...; kwargs...) = body\nfoo(args...; kwargs...) = _foo(args...; kwargs...)\n@adjoint foo(args...; kwargs...) = Zygote.pullback(_foo, args...; kwargs...)\n\nThat is, it defines the function as well as a Zygote adjoint which takes a gradient explicitly through the body of the function, rather than relying on rules which may be defined for foo. Mainly useful in the case that foo is a common function with existing rules, but which you do not want to be used.\n\n\n\n\n\n","category":"macro"},{"location":"api/#CMBLensing.@cpu!-Tuple","page":"API","title":"CMBLensing.@cpu!","text":"@cpu! x y\n\nEquivalent to x = cpu(x), y = cpu(y), etc... for any number of listed variables. See cpu.\n\n\n\n\n\n","category":"macro"},{"location":"api/#CMBLensing.@dict-Tuple","page":"API","title":"CMBLensing.@dict","text":"Pack some variables in a dictionary \n\n> x = 3\n> y = 4\n> @dict x y z=>5\nDict(:x=>3,:y=>4,:z=>5)\n\n\n\n\n\n","category":"macro"},{"location":"api/#CMBLensing.@distributed-Tuple","page":"API","title":"CMBLensing.@distributed","text":"CMBLensing.@distributed ds1 ds2 ...\n\nAssuming ds1, ds2, etc... are DataSet objects which are defined in the Main module on all workers, this makes it so that whenever these objects are shipped to a worker as part of a remote call, the data is not actually sent, but rather the worker just refers to their existing local copy. Typical usage:\n\n@everywhere ds = load_sim(seed=1, ...)\nCMBLensing.@distributed ds\npmap(1:n) do i\n    # do something with ds\nend\n\nNote that hash(ds) must yield the same value on all processors, ie the macro checks that it really is the same object on all processors. Sometimes setting the same random seed is not enough to ensure this as there may be tiny numerical differences in the simulated data. In this case you can try:\n\n@everywhere ds.d = $(ds.d)\n\nafter loading the dataset to explicitly set the data based on the simulation on the master process.\n\nAdditionally, if the dataset object has fields which are custom types, these must have an appropriate Base.hash defined. \n\n\n\n\n\n","category":"macro"},{"location":"api/#CMBLensing.@ismain-Tuple{}","page":"API","title":"CMBLensing.@ismain","text":"@ismain()\n\nReturn true if the current file is being run as a script.\n\n\n\n\n\n","category":"macro"},{"location":"api/#CMBLensing.@ondemand-Tuple{Any}","page":"API","title":"CMBLensing.@ondemand","text":"@ondemand(Package.function)(args...; kwargs...)\n@ondemand(Package.Submodule.function)(args...; kwargs...)\n\nJust like calling Package.function or Package.Submodule.function, but Package will be loaded on-demand if it is not already loaded. The call is no longer inferrable.\n\n\n\n\n\n","category":"macro"},{"location":"api/#CMBLensing.@repeated-Tuple{Any, Any}","page":"API","title":"CMBLensing.@repeated","text":"Return a tuple with the expression repeated n times \n\n\n\n\n\n","category":"macro"},{"location":"api/#CMBLensing.@show⌛-Tuple{Any}","page":"API","title":"CMBLensing.@show⌛","text":"See @⌛\n\n\n\n\n\n","category":"macro"},{"location":"api/#CMBLensing.@subst-Tuple{Any}","page":"API","title":"CMBLensing.@subst","text":"@subst sum(x*$(y+1) for x=1:2)\n\nbecomes\n\nlet tmp=(y+1)\n    sum(x*tmp for x=1:2)\nend\n\nto aid in writing clear/succinct code that doesn't recompute things unnecessarily.\n\n\n\n\n\n","category":"macro"},{"location":"api/#CMBLensing.@⌛-Tuple","page":"API","title":"CMBLensing.@⌛","text":"@⌛ [label] code ...\n@⌛ [label] function_definition() = ....\n\nLabel a section of code to be timed. If a label string is not provided, the first form uses the code itselfs as a label, the second uses the function name, and its the body of the function which is timed. \n\nTo run the timer and print output, returning the result of the calculation, use\n\n@show⌛ run_code()\n\nTiming uses TimerOutputs.get_defaulttimer(). \n\n\n\n\n\n","category":"macro"},{"location":"02_posterior/#The-Lensing-Posterior","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"","category":"section"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"At its heart, CMBLensing.jl is centered around the \"CMB lensing posterior\". We work with both the \"joint posterior\", which is joint over all variables,","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":" mathcalP(fphithetad) ","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"or the \"marginal posterior\", ","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":" mathcalP(phithetad) equiv int  mathcalDf  mathcalP(fphithetad) ","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"which is simply the joint posterior analytically marginalized over f. Here,","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"f are the CMB fields (T/Q/U),\nphi is the lensing potential,\ntheta are any cosmological parameters,\nd is the data.","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"The default data model which is assumed, which is generally flexible enough to handle real experiments (but can be customized), is:","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":" d =  mathbbA  mathbbL(phi)  f + n ","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"where","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":" mathbbA = mathbbM  mathbbB ","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"and ","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"mathbbL(phi) is the lensing operation\nmathbbB is an instrumental transfer function or \"beam\"\nmathbbM is a user-chosen mask\nn is the instrumental noise. ","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Given this model, the joint posterior (up to an unimportant normalization constant) is:","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":" \n-2lnmathcalP(fphithetad) = fracbig(d - mathbbA  mathbbL(phi)  fbig)^2mathbbC_n\n+ fracf^2mathbbC_f(theta) + fracphi^2C_phi(theta) + logdet mathbbC_f(theta) + logdet C_phi(theta)\n","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"and the marginal posterior is:","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":" \n-2lnmathcalP(phithetad) = fracd^2mathbbSigma_d(phitheta) + fracphi^2C_phi(theta) + logdet mathbbSigma_d(phitheta) + logdet C_phi(theta)\n","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"where","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"\nSigma_d = mathbbA  mathbbL(phi)  mathbbC_f(theta)  mathbbL(phi)^dagger mathbbA^dagger + mathbbC_n\n","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"and","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"mathbbC_n is the noise covariance\nmathbbC_f is the CMB covariance (i.e. the CMB T, E, and B C_ell's)\nmathbbC_phi is the lensing potential covariance (i.e. C_ell^phiphi)","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"and we have used the slighly sloppy notation x^2mathbbC to mean x^dagger mathbbC^-1 x.","category":"page"},{"location":"02_posterior/#Posterior-basics","page":"The Lensing Posterior","title":"Posterior basics","text":"","category":"section"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"using CMBLensing, PythonPlot","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"CMBLensing uses the function logpdf to compute the log of the joint posterior probability. ","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"To evaluate this posterior, we need the arguments of the probability distribution, f, phi, and theta. We also need the data d and host of other operators and covariances which enter the expressions above, which CMBLensing stores in a DataSet object.","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"First lets load up some simulated data. The function load_sim handles constructing a DataSet and is the recommended way to create the various fields and covariances needed. In this case, let's use 1muK-arcmin noise and a border mask:","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"(;f, f̃, ϕ, ds) = load_sim(\n    θpix      = 2,\n    Nside     = 256,\n    T         = Float64,\n    pol       = :P,\n    μKarcminT = 1,\n    L         = LenseFlow(10),\n    seed      = 0,\n    pixel_mask_kwargs = (edge_padding_deg=1, apodization_deg=0, num_ptsrcs=0),\n    bandpass_mask     = LowPass(5000)\n);","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"The DataSet object, by convention called ds, stores all the aforementioned quantities:","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"fieldnames(typeof(ds))","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"(:d, :Cf, :Cn, :Cn̂, :M, :M̂, :B, :B̂, :logprior, :Cϕ, :Cf̃, :D, :G, :L, :Nϕ)","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"For example, the data is:","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"plot(ds.d);","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"(Image: png)","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Or the diagonal of the mathbbC_f operator:","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"plot(diag(ds.Cf), which=[:El :Bl])","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"(Image: png)","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"We can now evaluate the posterior, for example at the true f and phi:","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"logpdf(ds; f, ϕ)","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"1.6745891005256723e6","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"There is a particular change-of-variables called the \"mixed parameterization\" (see our paper for details) which helps make the the posterior a little less correlated and more amenable to sampling and maximization. We can apply the change-of-variables to some point in parameter space as:","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"f°, ϕ° = mix(ds; f, ϕ);","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Then we can evaluate the posterior in the mixed parameterization:","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"logpdf(Mixed(ds); f°, ϕ°)","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"1.6745929299943913e6","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Note that this is the same value as above since we are just evaluating the same point in parameter space, just parameterized in terms of different variables.","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Above, we didn't specify any cosmological parameters, theta. Because of that, they were fixed at their fiducial values (i.e. the fiducial values which generated the simulated data in the call to load_sim earlier). Current only two parameters can be varied, r (tensor-to-scalar ratio), and A_phi (the amplitude of C_ell^phi phi). They can be specified as follows, with non-specified parameters left at their fiducial:","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"logpdf(ds; f, ϕ, θ=(Aϕ=1.1,))","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"1.6744484549757265e6","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"You can see the slight change compared to what we got above. We can even compute a whole slice through the posterior along A_phi:","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Aϕs = range(0.5,1.5,length=50)\nplot(Aϕs, [logpdf(ds; f, ϕ, θ=(;Aϕ)) for Aϕ in Aϕs])\nxlabel(raw\"$A_\\phi$\")\nylabel(raw\"$\\log\\mathcal{P}(f_{\\rm true}, \\phi_{\\rm true}, A_\\phi\\,|\\,d)$\");","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"(Image: png)","category":"page"},{"location":"02_posterior/#Wiener-filtering","page":"The Lensing Posterior","title":"Wiener filtering","text":"","category":"section"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"If we fix phi and theta then maximize the joint posterior, mathcalP(fphithetad), over f, we get","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"\nhat f_rm wf = big mathbbC_f(theta)^-1 + mathbbL(phi)^dagger mathbbA^daggermathbbC_n^-1mathbbA  mathbbL(phi) big^-1 mathbbL(phi)^dagger mathbbA^daggermathbbC_n^-1d\n","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"This is simply the Wiener filter of the data given a signal covariance which includes correlations induced by phi, and we can compute it by inverting the operator in brackets above with e.g. conjugate gradient. ","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"In CMBLensing.jl, the argmaxf_logpdf function performs this task. Its arguments are similar to logpdf,","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"f_wf, = argmaxf_logpdf(ds, (;ϕ); conjgrad_kwargs=(tol=1e-1,progress=true));","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"\u001b[32mConjugate Gradient: 100%|███████████████████████████████| Time: 0:00:11\u001b[39m","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Wiener filtering effectively delenses the data by a given phi. Here we are Wiener filtering at the true phi, so this is perfect delensing. Note below the large amount of B mode power in the data, as well as the aliasing near the border mask, and how this is removed in the Wiener filtered B, which visually is tracing the true B map up to the level of the noise.","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"plot([ds.d, f_wf, f], title=[\"data \", \"Wiener filtered \", \"true \"] .* [\"E\" \"B\"]);","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"(Image: png)","category":"page"},{"location":"02_posterior/#Posterior-gradients","page":"The Lensing Posterior","title":"Posterior gradients","text":"","category":"section"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Fundamental to maximization and sampling algorithms in high dimensions are gradients of the posterior. CMBLensing.jl uses the interface provided by the automatic differentiation library Zygote to compute these gradients.","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"using Zygote","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Zygote provides the gradient function, which takes a function for which to evaluate the gradient as the first argument, and the value at which to evaluate the gradient as the second argument. For example:","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"gradient(x->3x^2+2x, 1)","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"(8.0,)","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Gradients of the CMB lensing posterior work in exactly the same way. For example, to take the gradient with respect to phi in the mixed parametrization, where we fix f to the Wiener filter computed above and evaluate the gradient at phi=0, we can do:","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"gϕ = gradient(ϕ° -> logpdf(Mixed(ds); f°=f_wf, ϕ°), 0ϕ)[1];","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Here's what this gradient looks like multiplied by mathbbC_phi. This is actually the first gradient step in the iterative joint maximum a posteriori estimation. You can see below this very broadly matches the truth:","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"plot([ds.Cϕ*gϕ ϕ], title=[\"gradient step\" \"true ϕ\"])","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"(Image: png)","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"You are free to manipulate the fields inside of the function whose gradient is being taken, and Zygote will automatically propagate the chain rule for you:","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"gradient(ϕ -> -2logpdf(ds; f=f_wf, ϕ=3ϕ), 0ϕ)[1] ≈ -6 * gradient(ϕ -> logpdf(ds; f=f_wf, ϕ), 0ϕ)[1]","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"true","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Automatic differentiation with respect to any and all arguments of logpdf works, including the cosmological parameters:","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"gradient(Aϕ -> logpdf(ds; f, ϕ, θ=(;Aϕ)), 1)","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"(39.238434713564615,)","category":"page"},{"location":"02_posterior/","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Currently Zygote is working with many (but not all) operations that you can do to fields. If you run into things which Zygote is not able to differentiate successfully (generally you'll get some error), please feel free to file an Issue with CMBLensing.jl.","category":"page"},{"location":"03_joint_MAP_example/#MAP-estimation","page":"MAP estimation","title":"MAP estimation","text":"","category":"section"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"Here, we give an example of how to compute the joint maximum a posteriori (MAP) estimate of the CMB temperature and polarization fields, f, and the lensing potential, phi.","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"using CMBLensing, PythonPlot","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"\u001b[32m\u001b[1m    CondaPkg \u001b[22m\u001b[39m\u001b[0mFound dependencies: /home/cosmo/.julia/packages/PythonCall/wXfah/CondaPkg.toml\n\u001b[32m\u001b[1m    CondaPkg \u001b[22m\u001b[39m\u001b[0mFound dependencies: /home/cosmo/.julia/packages/PythonPlot/KcWMF/CondaPkg.toml\n\u001b[32m\u001b[1m    CondaPkg \u001b[22m\u001b[39m\u001b[0mFound dependencies: /home/cosmo/CMBLensing/CondaPkg.toml\n\u001b[32m\u001b[1m    CondaPkg \u001b[22m\u001b[39m\u001b[0mDependencies already up to date","category":"page"},{"location":"03_joint_MAP_example/#Compute-spectra","page":"MAP estimation","title":"Compute spectra","text":"","category":"section"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"First, we compute the fiducial CMB power spectra which generate our simulated data,","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"Cℓ = camb(r=0.05);","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"Next, we chose the noise power-spectra:","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"Cℓn = noiseCℓs(μKarcminT=1, ℓknee=100);","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"Plot these up for reference,","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"loglog(Cℓ.total.BB,c=\"C0\")\nloglog(Cℓ.unlensed_total.BB,\"--\",c=\"C0\")\nloglog(Cℓ.total.EE,c=\"C1\")\nloglog(Cℓ.unlensed_total.EE,\"--\",c=\"C1\")\nloglog(Cℓn.BB,\"k:\")\nlegend([\"lensed B\",\"unlensed B\",\"lensed E\",\"unlensed E\", \"noise (beam not deconvolved)\"]);","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"(Image: png)","category":"page"},{"location":"03_joint_MAP_example/#Configure-the-type-of-data","page":"MAP estimation","title":"Configure the type of data","text":"","category":"section"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"These describe the setup of the simulated data we are going to work with (and can be changed in this notebook),","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"θpix  = 3        # pixel size in arcmin\nNside = 128      # number of pixels per side in the map\npol   = :P       # type of data to use (can be :T, :P, or :TP)\nT     = Float32  # data type (Float32 is ~2 as fast as Float64);","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"Float32","category":"page"},{"location":"03_joint_MAP_example/#Generate-simulated-data","page":"MAP estimation","title":"Generate simulated data","text":"","category":"section"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"With these defined, the following generates the simulated data and returns the true unlensed and lensed CMB fields, f and f̃ ,and the true lensing potential, ϕ, as well as a number of other quantities stored in the \"DataSet\" object ds. ","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"(;f, f̃, ϕ, ds) = load_sim(\n    seed = 3,\n    Cℓ = Cℓ,\n    Cℓn = Cℓn,\n    θpix = θpix,\n    T = T,\n    Nside = Nside,\n    pol = pol,\n)\n\n(;Cf, Cϕ) = ds;","category":"page"},{"location":"03_joint_MAP_example/#Examine-simulated-data","page":"MAP estimation","title":"Examine simulated data","text":"","category":"section"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"The true phi map,","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"plot(ϕ, title = raw\"true $\\phi$\");","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"(Image: png)","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"The \"true\" unlensed field, f,","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"plot(f, title = \"true unlensed \" .* [\"E\" \"B\"]);","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"(Image: png)","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"And the \"true\" lensed field,","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"plot(LenseFlow(ϕ)*f, title = \"true lensed \" .* [\"E\" \"B\"]);","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"(Image: png)","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"The data (stored in the ds object) is basically f̃ with a beam applied plus a sample of the noise,","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"plot(ds.d, title = \"data \" .* [\"E\" \"B\"]);","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"(Image: png)","category":"page"},{"location":"03_joint_MAP_example/#Run-the-optimizer","page":"MAP estimation","title":"Run the optimizer","text":"","category":"section"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"Now we compute the maximum of the joint posterior, mathcalPbig(f phi bigdbig)","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"fJ, ϕJ, history = MAP_joint(ds, nsteps=30, progress=true);","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"\u001b[32mMAP_joint: 100%|████████████████████████████████████████| Time: 0:00:56\u001b[39m\n\u001b[34m  step:        30\u001b[39m\n\u001b[34m  logpdf:      402508.16\u001b[39m\n\u001b[34m  α:           0.23226348\u001b[39m\n\u001b[34m  ΔΩ°_norm:    7.5e-07\u001b[39m\n\u001b[34m  CG:          2 iterations (0.08 sec)\u001b[39m\n\u001b[34m  Linesearch:  15 bisections (0.50 sec)\u001b[39m","category":"page"},{"location":"03_joint_MAP_example/#Examine-results","page":"MAP estimation","title":"Examine results","text":"","category":"section"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"The history variable gives some info about the run, and more info can be saved by passing history_keys argument to MAP_joint. By default, we get just the value of the posterior, which we can use to check the maximizer has asymptoted to a maximum value:","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"plot(getindex.(history, :logpdf))\nxlabel(\"step\")\nylabel(\"logpdf\");","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"(Image: png)","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"Here's the best-fit phi relative to the truth,","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"plot(10^6*[ϕ ϕJ], title=[\"true\" \"best-fit\"] .* raw\" $\\phi$\", vlim=17);","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"(Image: png)","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"Here is the difference in terms of the power spectra. Note the best-fit has high-ell power suppressed, like a Wiener filter solution (in fact what we're doing here is akin to a non-linear Wiener filter). In the high S/N region (elllesssim1000), the difference is approixmately equal to the noise, which you can see is almost two orders of magnitude below the signal.","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"loglog(ℓ⁴ * Cℓ.total.ϕϕ, \"k\")\nloglog(get_ℓ⁴Cℓ(ϕ))\nloglog(get_ℓ⁴Cℓ(ϕJ))\nloglog(get_ℓ⁴Cℓ(ϕJ-ϕ))\nxlim(80,3000)\nylim(5e-9,2e-6)\nlegend([\"theory\",raw\"true $\\phi$\", raw\"best-fit $\\phi$\", \"difference\"])\nxlabel(raw\"$\\ell$\")\nylabel(raw\"$\\ell^4 C_\\ell$\");","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"(Image: png)","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"The best-fit unlensed fields relative to truth,","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"plot([f,fJ], title = [\"true\", \"best-fit\"] .* \" unlensed \" .* [\"E\" \"B\"]);","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"(Image: png)","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"The best-fit lensed field (bottom row) relative to truth (top row),","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"plot([f̃, LenseFlow(ϕJ)*fJ], title = [\"true\", \"best-fit\"] .* \" lensed \" .* [\"E\" \"B\"]);","category":"page"},{"location":"03_joint_MAP_example/","page":"MAP estimation","title":"MAP estimation","text":"(Image: png)","category":"page"},{"location":"06_gpu/#GPU","page":"GPU","title":"GPU","text":"","category":"section"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"CMBLensing uses CUDA.jl for GPU functionality. ","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"To use CUDA.jl, you'll need an Nvidia GPU and a recent version of the CUDA libraries. ","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"NERSC-specific instructions: On NERSC, just load the modules cudnn/7.6.5 and cuda/10.2.89 (other versions may work but those have been tested) and add export JULIA_CUDA_USE_BINARYBUILDER=false to your bashrc. ","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"See also install instructions for more info. ","category":"page"},{"location":"06_gpu/#CUDA-basics","page":"GPU","title":"CUDA basics","text":"","category":"section"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"We'll need these packages:","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"using CUDA, Adapt, CMBLensing, Random, PyPlot","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"To check everything loaded correctly:","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"CUDA.device()","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"CuDevice(0): GeForce GTX 1080 Ti","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"CUDA.functional()","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"true","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"CUDA.jl provides an array type called CuArray which is an array that resides on GPU. You can convert Arrays to CuArrays via the adapt function:","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"x_cpu = rand(128,128)\nx_gpu = adapt(CuArray, x_cpu)","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"128×128 CuArray{Float64,2}:\n 0.888712    0.824356   0.214376   …  0.755596    0.0433143  0.401218\n 0.860261    0.363934   0.758443      0.463215    0.438527   0.188045\n 0.486457    0.676236   0.265082      0.596669    0.633011   0.21782\n 0.922882    0.309495   0.372102      0.414542    0.851956   0.0997972\n 0.453549    0.502549   0.428112      0.238626    0.755366   0.611219\n 0.632588    0.812622   0.438778   …  0.229711    0.121807   0.358687\n 0.469266    0.0297919  0.0228982     0.287558    0.972336   0.338394\n 0.241879    0.375037   0.822643      0.458313    0.110923   0.0838822\n 0.147324    0.757712   0.416574      0.0792948   0.135277   0.95459\n 0.464468    0.515546   0.119434      0.392862    0.4709     0.334125\n 0.0577308   0.87099    0.286543   …  0.899621    0.349562   0.430823\n 0.460388    0.100913   0.2076        0.977196    0.225323   0.435314\n 0.38272     0.244247   0.468403      0.0425952   0.0149343  0.646776\n ⋮                                 ⋱  ⋮                      \n 0.342943    0.335381   0.377471      0.21693     0.812999   0.130155\n 0.66669     0.882168   0.967924      0.452162    0.0283182  0.781631\n 0.638998    0.371818   0.765243      0.0793586   0.380983   0.114074\n 0.0782665   0.167665   0.0335096     0.683306    0.719988   0.243631\n 0.859202    0.684524   0.0153715  …  0.826599    0.704447   0.270195\n 0.813795    0.964202   0.573068      0.165017    0.935501   0.744723\n 0.710874    0.314973   0.679694      0.246932    0.600466   0.794401\n 0.00634085  0.681718   0.78005       0.00949546  0.607457   0.697644\n 0.730091    0.535872   0.270631      0.420004    0.119571   0.692749\n 0.272711    0.645471   0.593968   …  0.903481    0.318548   0.279162\n 0.766253    0.89805    0.0506585     0.411019    0.947068   0.470326\n 0.0673976   0.96246    0.796442      0.937663    0.143763   0.847439","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"Any operations you now to do x_gpu are done on GPU and are super fast (although benchmarking can be subtle):","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"2 * x_gpu + x_gpu # happened on GPU","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"128×128 CuArray{Float64,2}:\n 2.66614    2.47307    0.643129   2.05436   …  2.26679    0.129943   1.20365\n 2.58078    1.0918     2.27533    0.812263     1.38964    1.31558    0.564134\n 1.45937    2.02871    0.795247   2.10365      1.79001    1.89903    0.653459\n 2.76865    0.928484   1.11631    2.65855      1.24363    2.55587    0.299392\n 1.36065    1.50765    1.28434    0.731794     0.715879   2.2661     1.83366\n 1.89776    2.43787    1.31634    1.06633   …  0.689134   0.365422   1.07606\n 1.4078     0.0893757  0.0686946  2.45819      0.862674   2.91701    1.01518\n 0.725638   1.12511    2.46793    2.58974      1.37494    0.332768   0.251647\n 0.441972   2.27313    1.24972    1.47896      0.237884   0.405831   2.86377\n 1.3934     1.54664    0.358303   1.21855      1.17859    1.4127     1.00237\n 0.173192   2.61297    0.859628   2.33799   …  2.69886    1.04869    1.29247\n 1.38117    0.302738   0.622801   0.252359     2.93159    0.675968   1.30594\n 1.14816    0.732742   1.40521    2.86669      0.127786   0.0448029  1.94033\n ⋮                                          ⋱  ⋮                     \n 1.02883    1.00614    1.13241    2.15201      0.650791   2.439      0.390466\n 2.00007    2.6465     2.90377    0.797989     1.35649    0.0849547  2.34489\n 1.91699    1.11545    2.29573    2.84374      0.238076   1.14295    0.342221\n 0.234799   0.502996   0.100529   2.7511       2.04992    2.15996    0.730892\n 2.5776     2.05357    0.0461144  2.03738   …  2.4798     2.11334    0.810584\n 2.44139    2.89261    1.7192     0.157185     0.495052   2.8065     2.23417\n 2.13262    0.944918   2.03908    2.11185      0.740797   1.8014     2.3832\n 0.0190226  2.04515    2.34015    2.55586      0.0284864  1.82237    2.09293\n 2.19027    1.60762    0.811894   2.44158      1.26001    0.358713   2.07825\n 0.818132   1.93641    1.7819     2.24219   …  2.71044    0.955644   0.837486\n 2.29876    2.69415    0.151975   2.74334      1.23306    2.8412     1.41098\n 0.202193   2.88738    2.38933    2.58541      2.81299    0.431288   2.54232","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"Note we also have three shorthands for using adapt: ","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"cu(x)  = adapt(CuArray{Float32}, x)\ngpu(x) = adapt(CuArray, x)\ncpu(x) = adapt(Array, x)","category":"page"},{"location":"06_gpu/#CMBLensing-GPU-basics","page":"GPU","title":"CMBLensing GPU basics","text":"","category":"section"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"CMBLensing fields can be put on GPU in exactly the same way.","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"f_cpu = FlatMap(rand(128,128))\nf_gpu = cu(f_cpu)","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"16384-element 128×128-pixel 1.0′-resolution FlatMap{CuArray{Float32,2},ProjLambert{Float32}}:\n 0.69471073\n 0.18825004\n 0.5484901\n 0.43423572\n 0.8342005\n 0.93333364\n 0.2082479\n 0.040642317\n 0.022252865\n 0.6725115\n 0.86915433\n 0.7677295\n 0.67226666\n ⋮\n 0.17374569\n 0.9538183\n 0.725677\n 0.45780742\n 0.15167615\n 0.47352484\n 0.21508026\n 0.99338794\n 0.8053882\n 0.23090039\n 0.32536042\n 0.082422785","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"Everything you can do to a CPU Field object you can do to a GPU one. ","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"f_gpu' * (2 * Fourier(f_gpu))","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"11048.801f0","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"cu(x) works recursively through most objects, for example through NamedTuples:","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"(x=f_cpu, y=f_cpu) |> typeof","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"NamedTuple{(:x, :y),Tuple{FlatMap{Array{Float64,2},ProjLambert{Float64}},FlatMap{Array{Float64,2},ProjLambert{Float64}}}}","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"cu((x=f_cpu, y=f_cpu)) |> typeof","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"NamedTuple{(:x, :y),Tuple{FlatMap{CuArray{Float32,2},ProjLambert{Float32}},FlatMap{CuArray{Float32,2},ProjLambert{Float32}}}}","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"You can move an entire DataSet to GPU too with cu(ds), which recursively moves all the fields and operators inside this object to GPU:","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"@unpack ds, ϕ = load_sim(Nside=256, θpix=3, pol=:P);","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"ds.d |> typeof","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"FlatEBFourier{Array{Complex{Float32},3},ProjLambert{Float32}}","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"cu(ds).d |> typeof","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"FlatEBFourier{CuArray{Complex{Float32},3},ProjLambert{Float32}}","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"You can also generate the DataSet directly on GPU, which is often much faster:","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"@unpack ds, ϕ = load_sim(Nside=256, θpix=3, pol=:P, storage=CuArray);","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"Once you have the DataSet object on GPU, all the normal high-level operations work on it, e.g.:","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"fJ,ϕJ = MAP_joint(ds, nsteps=10, progress=true);","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"\u001b[32mMAP_joint: 100%|████████████████████████████████████████| Time: 0:00:03\u001b[39m\n\u001b[34m  step:  10\u001b[39m\n\u001b[34m  χ²:    131546.67\u001b[39m\n\u001b[34m  Ncg:   3\u001b[39m","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"plot([ϕ ϕJ])","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"(Image: png)","category":"page"},{"location":"06_gpu/#Batching","page":"GPU","title":"Batching","text":"","category":"section"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"Just moving a DataSet to GPU will give you factors of about 2 - 10 speeds over CPU for Nside of 128 - 1024. You can go even faster by \"batching,\" which means doing the same operations to multiple fields at once, i.e. in \"batches\". The trick is that by putting multiple fields together into a single array, you reduce the number of GPU kernel calls needed as compared to simply looping over each field. This saves on the overhead of launching GPU kernels, and also often leads to accessing memory in a more efficient order. ","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"Suppose you had 10 fields on GPU that you want to lense:","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"fs = [simulate(ds.Cf) for i=1:10]\nϕs = [simulate(ds.Cϕ) for i=1:10];","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"You could do the following, and it might still be a little faster than doing it sequentially:","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"f̃s = [LenseFlow(ϕ)*f for (f,ϕ) in zip(fs,ϕs)];","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"But the really fast way to do it is pack those 10 fields into a batched field (note the indication these are batched in the printed type information):","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"f_batch = batch(fs)","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"660480-element 256×256(×10)-pixel 3.0′-resolution FlatEBFourier{CuArray{Complex{Float32},4},ProjLambert{Float32}}:\n         -0.0f0 + 0.0f0im\n   -2301.2195f0 + 3890.6575f0im\n    1402.1482f0 - 1060.4792f0im\n     2784.424f0 - 1058.4165f0im\n    -6349.881f0 - 975.9f0im\n   -5671.7495f0 - 2040.648f0im\n    5136.4106f0 + 1033.1976f0im\n    3956.7527f0 - 1917.7516f0im\n   -2445.4238f0 + 5727.068f0im\n    -745.9911f0 + 2247.4934f0im\n    2321.3606f0 - 1559.7291f0im\n    -5977.503f0 - 918.05707f0im\n    11611.693f0 + 2215.5535f0im\n                ⋮\n  -0.19412468f0 - 0.0999459f0im\n -0.016718278f0 - 0.028271351f0im\n -0.038219225f0 + 0.32705364f0im\n   -0.5447439f0 + 0.04154071f0im\n    0.4000634f0 + 0.21026817f0im\n  -0.08811981f0 - 0.060519397f0im\n  -0.36888558f0 + 0.1240009f0im\n   0.21560057f0 + 0.12047562f0im\n   0.21522556f0 + 0.13484338f0im\n   0.07516799f0 + 0.09902366f0im\n  -0.07842841f0 + 0.17105842f0im\n  -0.40802157f0 + 0.1223103f0im","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"ϕ_batch = batch(ϕs)","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"330240-element 256×256(×10)-pixel 3.0′-resolution FlatFourier{CuArray{Complex{Float32},4},ProjLambert{Float32}}:\n           -0.0f0 + 0.0f0im\n    -0.11784365f0 + 0.15110476f0im\n   -0.033175457f0 + 0.05291853f0im\n   -0.016406303f0 - 0.014861722f0im\n  -0.0018492909f0 + 0.0027736907f0im\n    -9.4121046f-5 - 0.0059507038f0im\n  -0.0046190238f0 + 0.008091824f0im\n     7.6152304f-5 + 0.00025117077f0im\n  -0.0008192814f0 - 0.0023286326f0im\n  -0.0032511519f0 + 0.00082712807f0im\n -0.00013448531f0 + 0.001952219f0im\n  -0.0018322299f0 + 0.0016523694f0im\n   -0.000556706f0 + 0.001031771f0im\n                  ⋮\n     1.1116966f-6 - 5.1770786f-7im\n    -5.3246663f-7 + 2.7610977f-7im\n    -2.0456389f-7 + 2.0728794f-6im\n    -2.1983196f-7 - 5.1164864f-7im\n     4.3068616f-7 + 5.444814f-7im\n     5.3897463f-7 + 1.2132183f-6im\n      3.334543f-7 - 2.5980754f-7im\n     1.9971692f-6 + 1.07297346f-7im\n     -4.118542f-7 - 1.1147516f-7im\n     1.6722242f-6 + 1.7814434f-8im\n    -2.3373966f-7 + 1.462492f-7im\n    1.13650565f-7 - 1.2209858f-6im","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"And then run the lensing operation once, which will lense each of the 10 fs by the corresponding ϕ. ","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"f̃_batch = LenseFlow(ϕ_batch) * f_batch","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"1310720-element 256×256(×10)-pixel 3.0′-resolution FlatQUMap{CuArray{Float32,4},ProjLambert{Float32}}:\n -1.4679776\n -2.0485938\n  0.23991281\n  0.20982413\n -0.42936718\n -2.967942\n -1.9101936\n -1.3053963\n -1.1134857\n -3.3083956\n -4.214875\n -6.73863\n -5.332464\n  ⋮\n  1.1316952\n  1.8423452\n  1.8628787\n -2.643449\n -4.822819\n -1.0603839\n  3.825707\n  1.9785323\n -1.6165124\n -3.4116428\n -3.8029394\n -2.3072338","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"Speedups over simple looping will depend significantly on how good your GPU hardware is, but e.g. for the problem size of Nside=256 on a Tesla V100, doing this batch of 10 lenses is almost no slower than doing a single one.","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"You can get the individual fields out of the batched result with batch_index, e.g. the first 2 (out of 10) lensed B fields:","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"plot([batch_index(f̃_batch,1) batch_index(f̃_batch, 2)], which=:Bx)","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"(Image: png)","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"f[!,i] is short-hand for batch_index(f,i), meant to be used when doing interactive work:","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"f_batch[!,1] == batch_index(f_batch,1)","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"true","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"Normal broadcasting rules apply between batched and non-batched fields, so e.g.:","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"LenseFlow(ϕ) * f_batch","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"1310720-element 256×256(×10)-pixel 3.0′-resolution FlatQUMap{CuArray{Float32,4},ProjLambert{Float32}}:\n -1.4941235\n -0.9914128\n  1.0198733\n  0.88523036\n -0.6625598\n -3.2031393\n -2.0574992\n -1.7696751\n -1.2420458\n -3.2735085\n -4.4636745\n -6.023631\n -6.9492006\n  ⋮\n  1.3844602\n  3.487194\n  3.0349822\n -1.9964567\n -3.3094363\n  1.3220795\n  2.9720027\n  0.91866386\n -2.3997512\n -4.35118\n -6.19135\n -6.4957414","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"works and lenses the 10 different fields in f_batch by the same (non-batched) ϕ.","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"Most of CMBLensing works with batched fields just like with normal fields. This includes things like lnP, conjugate_gradient, sample_joint, or MAP_joint (although MAP_marg only works with non-batched fields, but will be fixed in the future).","category":"page"},{"location":"06_gpu/#Multiple-GPUs","page":"GPU","title":"Multiple GPUs","text":"","category":"section"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"For multi-GPU runs, the easiest way currently is to use one Julia process per GPU. See also the section of the CUDA.jl documentation here. (Note, this is under active developement and it seems likely in the future it will become easier to use multiple GPUs from the same process, saving on memory and startup cost.)","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"If all your GPUs are on one node, you can use the following code snippet to set up parallel GPUs. Here e.g. we have 4 GPUs, so we launch 4 worker processes:","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"using Distributed\naddprocs(4, exeflags=\"--project=@.\")\n@everywhere using CMBLensing\nCMBLensing.assign_GPU_workers()","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"GPU_worker_info:\n(master = 1, host = n0299.savio2, device = CuDevice(0): GeForce GTX 1080 Ti 04321c79)\n(worker = 2, host = n0299.savio2, device = CuDevice(1): GeForce GTX 1080 Ti eb8fcbf6)\n(worker = 3, host = n0299.savio2, device = CuDevice(2): GeForce GTX 1080 Ti 5b58bff4)\n(worker = 4, host = n0299.savio2, device = CuDevice(3): GeForce GTX 1080 Ti 0493ddcc)\n(worker = 5, host = n0299.savio2, device = CuDevice(0): GeForce GTX 1080 Ti 04321c79)","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"Now you can use normal Julia parallel constructs to assign work to each GPU. E.g., we can lense each of the batched maps above on separate GPUs: ","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"batch(pmap(fs, ϕs) do f,ϕ\n    LenseFlow(ϕ) * f\nend)","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"1310720-element 256×256(×10)-pixel 3.0′-resolution FlatQUMap{CuArray{Float32,4},ProjLambert{Float32}}:\n -1.4679776\n -2.0485938\n  0.23991281\n  0.20982413\n -0.42936718\n -2.967942\n -1.9101936\n -1.3053963\n -1.1134857\n -3.3083956\n -4.214875\n -6.73863\n -5.332464\n  ⋮\n  1.1316952\n  1.8423452\n  1.8628787\n -2.643449\n -4.822819\n -1.0603839\n  3.825707\n  1.9785323\n -1.6165124\n -3.4116428\n -3.8029394\n -2.3072338","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"Note that CPU and GPU fields are completely serializable and can be sent back and forth to worker processes, such as happened above. When a GPU fields is sent, it will be copied to the worker's GPU transparently. However, note that it has to pass through CPU memory, so there is sizeable overhead. E.g., in the example above, its much faster to perform the batch lense on 1 GPU rather than split across the 4. Indeed, parallel constructs like this are mainly useful for parallelizing over larger workloads where the overhead is insignificant. ","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"For multi-GPU multi-node jobs, its recommended to set up Julia workers via MPIClusterManagers.jl. CMBLensing.assign_GPU_workers() works with multi-node jobs as well (and knows to assign GPUs to workers only on the same node).","category":"page"},{"location":"06_gpu/#Gotchas","page":"GPU","title":"Gotchas","text":"","category":"section"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"Not much, hopefully. If something that works on CPU doesn't work on GPU, please file an Issue.","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"One thing to keep in mind is that CPU and GPU use different random number generators, so seeds will not correspond. Note however you can force a GPU simulation to use the CPU RNG by passing rng=MersenneTwister().","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"plot(permutedims(cpu.([\n    simulate(cpu(ds.Cϕ),seed=0),                         # simulate CPU field\n    simulate( cu(ds.Cϕ),seed=0),                         # simulate GPU field\n    simulate( cu(ds.Cϕ),seed=0,rng=MersenneTwister())    # simulate GPU field using CPU RNG\n])))","category":"page"},{"location":"06_gpu/","page":"GPU","title":"GPU","text":"(Image: png)","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"%pylab inline","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"%pylab is deprecated, use %matplotlib inline and import the required libraries.\nPopulating the interactive namespace from numpy and matplotlib","category":"page"},{"location":"04_from_python/#Calling-from-Python","page":"Calling from Python","title":"Calling from Python","text":"","category":"section"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"You can call Julia and CMBLensing.jl directly from Python. This is made possible by the juliacall package. You can install it into your Python environment with, e.g.:","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"$ pip install --user juliacall","category":"page"},{"location":"04_from_python/#Basics-of-calling-Julia","page":"Calling from Python","title":"Basics of calling Julia","text":"","category":"section"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"Once juliacall is installed, first point it to the Julia environment environment you want active (the one with your desired CMBLensing version in it):","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"import os\nos.environ[\"PYTHON_JULIAPKG_PROJECT\"] = \"/home/cosmo/CMBLensing/docs\"\nos.environ[\"PYTHON_JULIAPKG_OFFLINE\"] = \"yes\"","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"Then import juliacall:","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"from juliacall import Main as jl","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"[juliapkg] Locating Julia ^1.6.1\n[juliapkg] Using Julia 1.9.3 at /usr/local/bin/julia\n[juliapkg] Using Julia project at /home/cosmo/CMBLensing/docs","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"The jl object represents the Julia Main model, for example:","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"jl.cos(1) # <--- this is Julia's cosine function","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"0.5403023058681398","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"You can also run arbitrary Julia code (this is helpful if you want to use Julia language features or syntax which don't exist in Python). For example, 1:10 is not valid Python syntax, but you can do:","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"jl.seval(\"1:10\")","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"range(1, 11)","category":"page"},{"location":"04_from_python/#Calling-CMBLensing.jl","page":"Calling from Python","title":"Calling CMBLensing.jl","text":"","category":"section"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"You can use seval to essentially just paste Julia code into Python session, for example, following the Lensing a flat-sky map example:","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"jl.seval(\"\"\"\nusing CMBLensing\n\"\"\")","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"Next, we simulate some data:","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"jl.seval(\"\"\"\n(;f, ϕ) = load_sim(\n    θpix  = 2,\n    Nside = 256,\n    T     = Float32,\n    pol   = :P\n);\n\"\"\");","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"...and we could continue the example as desired.","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"Variables defined by seval can be accessed directly in the Main module, and are automatically converted to Python-usage objects, e.g:","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"matshow(jl.seval(\"f[:Ex]\"))","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"<matplotlib.image.AxesImage at 0x7fc3b03731f0>","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"(Image: png)","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"You can also pass Python objects into Julia function, and they are converted as well:","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"jl.FlatMap(np.random.randn(10,10))","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"100-element 10×10-pixel 1.0′-resolution LambertMap{PyArray{Float64, 2, true, false, Float64}}:\n -1.5573023347790027\n  1.0959178403337626\n  0.9519254819830556\n -0.038381463119681714\n -1.1669838327345632\n -0.6330561330058494\n  0.443407675488603\n  0.07599267953053207\n -0.8986860009336953\n  0.2181276822253109\n  ⋮\n -0.12310637681170047\n  0.06658744059133963\n -0.8741147226673158\n  0.27311279683698786\n -0.18195798300399588\n  0.8867024667679957\n  0.7318639728278861\n  0.4945647711445212\n -0.47461166370745245","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"See the documentation for PythonCall / juliacall for more details.","category":"page"},{"location":"04_from_python/#Plotting","page":"Calling from Python","title":"Plotting","text":"","category":"section"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"If you want to use special plotting of maps defined in Julia, be sure to use the Julia plot function not the Python one:","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"jl.seval(\"\"\"\nusing PythonPlot\n\"\"\")","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"┌ Warning: No working GUI backend found for matplotlib\n└ @ PythonPlot ~/.julia/packages/PythonPlot/KcWMF/src/init.jl:128","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"jl.plot(jl.f)","category":"page"},{"location":"04_from_python/","page":"Calling from Python","title":"Calling from Python","text":"(Image: png)","category":"page"},{"location":"precompilation/#Startup","page":"Startup","title":"Startup","text":"","category":"section"},{"location":"precompilation/","page":"Startup","title":"Startup","text":"If using Julia 1.9 or above, you can get large speedups (about 10X) in startup time by using the native code caching feature. The idea is that when precompiling CMBLensing, several typically-used functions are run and precompiled, making them much faster to use in subsequent sessions. ","category":"page"},{"location":"precompilation/","page":"Startup","title":"Startup","text":"Because this can make precompilation of CMBLensing take somewhat longer (a few minutes), its disabled by default. But you can enable it by running, ","category":"page"},{"location":"precompilation/","page":"Startup","title":"Startup","text":"julia> using CMBLensing\n\njulia> CMBLensing.set_preferences!(CMBLensing, \"precompile\" => true)","category":"page"},{"location":"precompilation/","page":"Startup","title":"Startup","text":"The setting will be stored in a file called LocalPreferences.toml in your active environment (which you are free to edit by hand). The next time you start Julia it will precompile CMBLensing (which will now take a few minutes), but after that startup will be much faster. The precompilation calls the following functions:","category":"page"},{"location":"precompilation/","page":"Startup","title":"Startup","text":"load_sim\nlogpdf\ngradient of logpdf","category":"page"},{"location":"precompilation/","page":"Startup","title":"Startup","text":"with Float32 and Float64 CPU arrays for a dataset with pol=:I, pol=:P, and pol=:IP. Those funtions and any called by those functions will be much faster on first call after precompilation is enabled. If you don't need all those combinations, its also possible to specify just a subset of them, e.g.:","category":"page"},{"location":"precompilation/","page":"Startup","title":"Startup","text":"julia> CMBLensing.set_preferences!(CMBLensing, \"precompile\" => \"[(:P, Float32, Array))]\")","category":"page"},{"location":"precompilation/","page":"Startup","title":"Startup","text":"For even more speedups and control over what to precompile, you can create a \"Startup\" package following the instruction here: PrecompileTools.jl#Startup.","category":"page"},{"location":"05_field_basics/#Field-Basics","page":"Field Basics","title":"Field Basics","text":"","category":"section"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"using CMBLensing","category":"page"},{"location":"05_field_basics/#Base-Fields","page":"Field Basics","title":"Base Fields","text":"","category":"section"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"The basic building blocks of CMBLensing.jl are CMB \"fields\", like temperature, Q or U polarization, or the lensing potential phi. These types are all encompassed by the abstract type Field, with some concrete examples including FlatMap for a flat-sky map projection, or FlatQUMap for Q/U polarization, etc...","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"Flat fields are just thin wrappers around Julia arrays, e.g.","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"Ix = rand(2,2)","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"2×2 Matrix{Float64}:\n 0.791579  0.122001\n 0.747891  0.484126","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"f = FlatMap(Ix)","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"4-element 2×2-pixel 1.0′-resolution LambertMap{Array{Float64, 2}}:\n 0.7915791207108701\n 0.7478911009853889\n 0.12200078444323892\n 0.4841256229149363","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"When displayed, you can see the pixels in the 2x2 map have been splayed out into a length-4 array. This is intentional, as even though the maps themselves are two-dimensional, it is extremely useful conceptually to think of fields as vectors (which they are, in fact, as they form an abstract vector space). This tie to vector spaces is deeply rooted in CMBLensing, to the extent that Field objects are a subtype of Julia's own AbstractVector type, ","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"f isa AbstractVector","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"true","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"The data itself, however, is still stored as the original 2x2 matrix, and can be accessed as follows,","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"f.Ix","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"2×2 view(::Matrix{Float64}, :, :) with eltype Float64:\n 0.791579  0.122001\n 0.747891  0.484126","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"But since Fields are vectors, they can be tranposed,","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"f'","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"1×4 adjoint(::LambertMap{Array{Float64, 2}}) with eltype Float64:\n 0.791579  0.747891  0.122001  0.484126","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"inner products can be computed,","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"f' * f","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"1.4352004134460723","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"and they can be added with each other as well as multiplied by scalars,","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"2*f+f","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"4-element 2×2-pixel 1.0′-resolution LambertMap{Array{Float64, 2}}:\n 2.37473736213261\n 2.2436733029561666\n 0.36600235332971676\n 1.452376868744809","category":"page"},{"location":"05_field_basics/#Diagonal-operators","page":"Field Basics","title":"Diagonal operators","text":"","category":"section"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"Vector spaces have linear operators which act on the vectors. Linear operators correpsond to matrices, thus for a map with N total pixels, a general linear operator would be an N-by-N matrix, which for even modest map sizes becomes far too large to actually store. Thus, an important class of linear operators are ones which are diagonal, since these can actually be stored. CMBLensing uses Julia's builtin Diagonal to represent these. Diagonal(f) takes a vector f and puts it on the diagonal of the matrix:","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"Diagonal(f)","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"4×4 Diagonal{Float64, BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}}:\n 0.791579   ⋅         ⋅         ⋅ \n  ⋅        0.747891   ⋅         ⋅ \n  ⋅         ⋅        0.122001   ⋅ \n  ⋅         ⋅         ⋅        0.484126","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"Multiplying this operator by the original map is then a matrix-vector product:","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"Diagonal(f) * f","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"4-element 2×2-pixel 1.0′-resolution LambertMap{Array{Float64, 2}}:\n 0.6265975043453943\n 0.5593410989331372\n 0.014884191404765648\n 0.23437761876277513","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"Note that this is also equal to the the pointwise multiplication of f with itself:","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"f .* f","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"4-element 2×2-pixel 1.0′-resolution LambertMap{Array{Float64, 2}}:\n 0.6265975043453943\n 0.5593410989331372\n 0.014884191404765648\n 0.23437761876277513","category":"page"},{"location":"05_field_basics/#Field-Tuples","page":"Field Basics","title":"Field Tuples","text":"","category":"section"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"You can put Fields together into tuples. For example, ","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"a = FlatMap(rand(2,2))\nb = FlatMap(rand(2,2));","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"FieldTuple(a,b)","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"8-element Field-2-Tuple{BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}, BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}}:\n 0.05553470245958003\n 0.5613686533003903\n 0.15598472262801066\n 0.3990035727328386\n 0.019565391929818765\n 0.08390502755152796\n 0.7022876296827427\n 0.689956425641495","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"The components can also have names:","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"ft = FieldTuple(a=a, b=b)","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"8-element Field-(a,b)-Tuple{BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}, BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}}:\n 0.05553470245958003\n 0.5613686533003903\n 0.15598472262801066\n 0.3990035727328386\n 0.019565391929818765\n 0.08390502755152796\n 0.7022876296827427\n 0.689956425641495","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"which can be accessed later:","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"ft.a","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"4-element 2×2-pixel 1.0′-resolution LambertMap{Array{Float64, 2}}:\n 0.05553470245958003\n 0.5613686533003903\n 0.15598472262801066\n 0.3990035727328386","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"FieldTuples have all of the same behavior of individual fields. Indeed, spin fields like QU or IQU are simply special FieldTuples:","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"fqu = FlatQUMap(a,b)\nfqu isa FieldTuple","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"false","category":"page"},{"location":"05_field_basics/#Field-Vectors","page":"Field Basics","title":"Field Vectors","text":"","category":"section"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"in progress","category":"page"},{"location":"05_field_basics/#Basis-Conversion","page":"Field Basics","title":"Basis Conversion","text":"","category":"section"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"All fields are tagged as to which basis they are stored in. You can convert them to other bases by calling the basis type on them:","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"f","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"4-element 2×2-pixel 1.0′-resolution LambertMap{Array{Float64, 2}}:\n 0.7915791207108701\n 0.7478911009853889\n 0.12200078444323892\n 0.4841256229149363","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"g = Fourier(f)","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"4-element 2×2-pixel 1.0′-resolution LambertFourier{Array{ComplexF64, 2}}:\n   2.145596629054434 + 0.0im\n -0.3184368187462162 + 0.0im\n  0.9333438143380838 + 0.0im\n  0.4058128581971786 + 0.0im","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"Basis conversion is usually done automatically for you. E.g. here f′ is automatically converted to a FlatMap before addition:","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"f + g","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"4-element 2×2-pixel 1.0′-resolution LambertMap{Array{Float64, 2}}:\n 1.5831582414217402\n 1.4957822019707778\n 0.24400156888647778\n 0.9682512458298727","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"A key feature of Diagonal operators is they convert the field they are acting on to the right basis before multiplication:","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"Diagonal(f) * g","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"4-element 2×2-pixel 1.0′-resolution LambertMap{Array{Float64, 2}}:\n 0.6265975043453943\n 0.5593410989331372\n 0.014884191404765641\n 0.2343776187627751","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"A FlatMap times a FlatFourier doesn't have a natural linear algebra meaning so its an error:","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"f * g","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"MethodError: no method matching *(::BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}, ::BaseField{Fourier, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, ComplexF64, Matrix{ComplexF64}})\n\nClosest candidates are:\n  *(::Any, ::Any, ::Any, ::Any...)\n   @ Base operators.jl:578\n  *(::Field, ::LinearAlgebra.Adjoint{<:Any, <:StaticArraysCore.StaticArray{Tuple{2}, F, 1}} where F<:Union{Field, FieldOp})\n   @ CMBLensing ~/CMBLensing/src/field_vectors.jl:35\n  *(::Field, ::StaticArraysCore.StaticArray{Tuple{2}, F, 1} where F<:Union{Field, FieldOp})\n   @ CMBLensing ~/CMBLensing/src/field_vectors.jl:34\n  ...\n\n\n\n\nStacktrace:\n\n [1] top-level scope\n\n   @ In[21]:1","category":"page"},{"location":"05_field_basics/#Properties-and-indices","page":"Field Basics","title":"Properties and indices","text":"","category":"section"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"FlatMap and FlatFourier can be indexed directly like arrays. If given 1D indices, this is the index into the vector representation:","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"f","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"4-element 2×2-pixel 1.0′-resolution LambertMap{Array{Float64, 2}}:\n 0.7915791207108701\n 0.7478911009853889\n 0.12200078444323892\n 0.4841256229149363","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"f[1], f[2], f[3], f[4]","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"(0.7915791207108701, 0.7478911009853889, 0.12200078444323892, 0.4841256229149363)","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"f[5]","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"BoundsError: attempt to access 2×2 Matrix{Float64} at index [5]\n\n\n\nStacktrace:\n\n [1] getindex\n\n   @ ./essentials.jl:13 [inlined]\n\n [2] getindex(f::BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}, I::Int64)\n\n   @ CMBLensing ~/CMBLensing/src/base_fields.jl:36\n\n [3] top-level scope\n\n   @ In[24]:1","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"Or with a 2D index, this indexes directly into the 2D map:","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"f[1,1], f[2,1], f[1,2], f[2,2]","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"(0.7915791207108701, 0.7478911009853889, 0.12200078444323892, 0.4841256229149363)","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"Note: there is no overhead to indexing f in this way as compared to working directly on the underlying array.","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"For other fields which are built on FieldTuples, 1D indexing will instead index the tuple indices:","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"ft","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"8-element Field-(a,b)-Tuple{BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}, BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}}:\n 0.05553470245958003\n 0.5613686533003903\n 0.15598472262801066\n 0.3990035727328386\n 0.019565391929818765\n 0.08390502755152796\n 0.7022876296827427\n 0.689956425641495","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"ft[1]","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"4-element 2×2-pixel 1.0′-resolution LambertMap{Array{Float64, 2}}:\n 0.05553470245958003\n 0.5613686533003903\n 0.15598472262801066\n 0.3990035727328386","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"ft[2]","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"4-element 2×2-pixel 1.0′-resolution LambertMap{Array{Float64, 2}}:\n 0.019565391929818765\n 0.08390502755152796\n 0.7022876296827427\n 0.689956425641495","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"ft[3]","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"BoundsError: attempt to access NamedTuple{(:a, :b), Tuple{BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}, BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}}} at index [3]\n\n\n\nStacktrace:\n\n [1] getindex\n\n   @ ./namedtuple.jl:136 [inlined]\n\n [2] getindex(f::FieldTuple{NamedTuple{(:a, :b), Tuple{BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}, BaseField{Map, ProjLambert{Float64, Vector{Float64}, Matrix{Float64}}, Float64, Matrix{Float64}}}}, CMBLensing.BasisProd{Tuple{Map, Map}}, Float64}, i::Int64)\n\n   @ CMBLensing ~/CMBLensing/src/field_tuples.jl:33\n\n [3] top-level scope\n\n   @ In[29]:1","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"To get the underlying data arrays, use the object's properties:","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"f.Ix","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"2×2 view(::Matrix{Float64}, :, :) with eltype Float64:\n 0.791579  0.122001\n 0.747891  0.484126","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"You can always find out what properties are available by typing f.<Tab>. For example, if you typed ft then hit <Tab> you'd get:","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"ft |> propertynames","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"(:fs, :a, :b)","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"For a FieldTuple like the FlatQUMap object, fqu, you can get each individual Q or U field:","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"fqu.Q","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"4-element 2×2-pixel 1.0′-resolution LambertMap{SubArray{Float64, 2, Array{Float64, 3}, Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, Int64}, true}}:\n 0.05553470245958003\n 0.5613686533003903\n 0.15598472262801066\n 0.3990035727328386","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"Or fqu.Qx which is shorthand for fqu.Q.Ix:","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"fqu.Q.Ix === fqu.Qx","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"true","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"If you convert f to Fourier space, it would have the Il property to get the Fourier coefficients of the I component:","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"Fourier(f).Il","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"2×2 view(::Matrix{ComplexF64}, :, :) with eltype ComplexF64:\n    2.1456+0.0im  0.933344+0.0im\n -0.318437+0.0im  0.405813+0.0im","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"For convenience, you can index fields with brackets [] and any necessary conversions will be done automatically:","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"f[:Il]","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"2×2 view(::Matrix{ComplexF64}, :, :) with eltype ComplexF64:\n    2.1456+0.0im  0.933344+0.0im\n -0.318437+0.0im  0.405813+0.0im","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"This works between any bases. For example. fqu is originally QUMap but we can convert to EBFourier and get the El coefficients:","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"fqu[:El]","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"2×2 view(::Array{ComplexF64, 3}, :, :, 1) with eltype ComplexF64:\n  -1.17189-0.0im  -0.0619151+0.0im\n -0.748853+0.0im   0.0766708+0.0im","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"The general rule to keep in mind for these two ways of accessing the underlying data is:","category":"page"},{"location":"05_field_basics/","page":"Field Basics","title":"Field Basics","text":"Properties (i.e. f.Ix) are type-stable and get you the underlying data arrays, even recursively from special FieldTuples like FlatQUMap, etc... If these arrays are modified, they affect the original field.\nIndices (i.e. f[:Ix]) are not type-stable, and may or may not be one of the underlying data arrays (because a basis conversion may have been performed). They should be used for getting (not setting) data, and in non-performance-critical code. ","category":"page"},{"location":"#CMBLensing.jl","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"","category":"section"},{"location":"","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"(Image: ) (Image: Gitter)","category":"page"},{"location":"","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"(Image: )  (Image: Binder)  (Image: ) (Image: ) ","category":"page"},{"location":"","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"CMBLensing.jl is a next-generation tool for analysis of the lensed Cosmic Microwave Background. It is written in Julia and transparently callable from Python.","category":"page"},{"location":"","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"At its heart, CMBLensing.jl maximizes, samples, or performs MUSE inference on the Bayesian posterior for the CMB lensing problem. It also contains tools to quickly manipulate and process CMB maps, set up modified posteriors with a probabilistic programming language, and take gradients using automatic differentiation.","category":"page"},{"location":"#Highlights","page":"CMBLensing.jl","title":"Highlights","text":"","category":"section"},{"location":"","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"Fully Nvidia GPU compatible (1-2 orders of magnitude speedups over CPU, depending on the problem size and hardware).\nAutomatic differentiation (via Zygote.jl) provides for-free gradients of your custom posteriors.\nIncludes the following algorithms to lense a map:\nLenseFlow (Millea, Anderes, & Wandelt 2017)\nTaylens (Næss & Louis 2013)\nTaylor series expansion to any order\nBilinear interpolation\nMaximize and sample mathcalP(fphithetad), the joint maximum a posteriori estimate of the lensing potential, phi, the  temperature and/or polarization fields, f, and cosmological parameters, theta (Millea, Anderes, & Wandelt 2017, Millea, Anderes, & Wandelt 2020)\nMaximize mathcalP(phidtheta), i.e. the marginal maximum a posteriori estimate of the lensing potential, phi, at fixed cosmological parameters, theta (Carron & Lewis 2017)\nCompute MUSE inferences of bandpowers of phi and unlensed f via MuseInference.jl (Millea & Seljak, 2021).\nDo basic quadratic estimation of phi (Hu & Okamoto 2003)","category":"page"},{"location":"#Documentation","page":"CMBLensing.jl","title":"Documentation","text":"","category":"section"},{"location":"","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"The best place to get started is to read the documentation (which is a work-in-progress, but contains many useful examples). ","category":"page"},{"location":"","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"Most of the pages in the documentation are Jupyter notebooks, and you can click the \"launch binder\" link at the top of each page to launch a Jupyterlab server running the notebook in your browser (courtesy of binder). ","category":"page"},{"location":"","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"You can also clone the repository and open the notebooks in docs/src if you want to run them locally (which will usually lead to higher performance). The notebooks are stored as .md files rather than .ipynb format. Its recommended to install Jupytext (pip install jupytext) and then you can run these .md directly from Jupyterlab by right-clicking on them and selecting Open With -> Notebook. Otherwise, run the script docs/make_notebooks.sh to convert the .md files to .ipynb which you can then open as desired. ","category":"page"},{"location":"#Installation","page":"CMBLensing.jl","title":"Installation","text":"","category":"section"},{"location":"#Requirements","page":"CMBLensing.jl","title":"Requirements","text":"","category":"section"},{"location":"","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"Julia 1.8+\n(recommended) An Nvidia GPU and CUDA.jl for GPU support\n(recommended) Python 3 + matplotlib (used for plotting)\n(recommended) pycamb to generate C_ell's (run pip install --user camb)\n(recommended) JuliaMono font to ensure characters like f̃, ϕ, ∇, ℓ, etc... are rendered correctly","category":"page"},{"location":"#Native-installation","page":"CMBLensing.jl","title":"Native installation","text":"","category":"section"},{"location":"","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"To install the Julia package locally, run:","category":"page"},{"location":"","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"pkg> add CMBLensing","category":"page"},{"location":"","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"(type ] at the Julia REPL to reach the pkg> prompt)","category":"page"},{"location":"","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"(recommended) After installing, switch your Julia to use Intel MKL FFT libraries, which provide significantly faster FFTs when running on CPU. You can do so by running using CMBLensing.FFTW; FFTW.set_provider!(\"mkl\") from the same environment in which you added CMBLensing. This only needs to be done once per-environment (see also here).","category":"page"},{"location":"#Docker-installation","page":"CMBLensing.jl","title":"Docker installation","text":"","category":"section"},{"location":"","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"Also provided is a Docker container which includes a Jupyterlab server and all the recommended and optional dependencies to run and use CMBLensing.jl. Launch this container with:","category":"page"},{"location":"","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"git clone https://github.com/marius311/CMBLensing.jl.git\ncd CMBLensing.jl\ndocker-compose pull main\ndocker-compose up main","category":"page"},{"location":"","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"The first time you run this, it will automatically download the (~1Gb) container from the Docker hub. The command will prompt you with the URL which you should open in a browser to access the notebook.","category":"page"},{"location":"","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"To run the notebook on a different port than the default 8888, do PORT=1234 docker-compose up main where 1234 is whatever port number you want.","category":"page"},{"location":"","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"You can also build the container locally by replacing docker-compose pull main with docker-compose build main.","category":"page"}]
}
